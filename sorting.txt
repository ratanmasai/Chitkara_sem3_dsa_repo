Sorting:
=========


--Sorting is the process of arranging data (typically in arrays or lists) in a particular order—ascending or descending.


Sorting helps to:

--Improve searching efficiency (e.g., binary search).

--Present data in a meaningful format.

--Optimize data-related algorithms like merging, searching, and duplicate detection.



Types of Sorting Techniques:
----------------------------

Sorting algorithms are broadly categorized into 2 types:

1. Comparison-based sorting:

	--Bubble Sort 
	--Selection Sort 
	--Insertion Sort 
	--Merge Sort 
	--Quick Sort
	--Heap Sort

2. Non-comparison-based sorting:

	--Counting Sort
	--Radix Sort 
	--Bucket Sort



Bubble Sort:
============

Concept:
--------

--Bubble Sort compares adjacent elements and swaps them if they are in the wrong order. 
--This process is repeated until the array is sorted.
-- Larger elements (bubbles) move to the end of the array with each pass, like bubbles floating up.


Step-by-Step Procedure:
-----------------------

1. Start from the first element and compare with the next.

2. If the current element is greater, swap them. (e.g. arr[j] > arr[j+1] for ascending order)

3. Move to the next pair and repeat until the end.

4. After one complete pass, the largest element is at the end.

Repeat the process for remaining unsorted part.


Example:
---------

Let’s sort: arr = [5, 3, 1, 4] in acsending order


Pass1:

[5, 3, 1, 4] => compare 5 and 3 => swap => [3, 5, 1, 4]
[3, 5, 1, 4] => compare 5 and 1 => swap => [3, 1, 5, 4]
[3, 1, 5, 4] => compare 5 and 4 => swap => [3, 1, 4, 5]

at the end of pass 1 the last element get its sorted position

Pass2: 

[3, 1, 4, 5] => compare 3 and 1 => swap => [1, 3, 4, 5]
[1, 3, 4, 5] => compare 3 and 4 => no swap
[1, 3, 4, 5] => compare 4 and 5 => no swap


Pass3:
[1, 3, 4, 5] => already sorted




Code:
------


void bubbleSort(vector<int>& arr){

    //outer loop for each pass
    for(int i=0;i<arr.size()-1;i++){

        //inner loop for compare adjacent elements
        for(int j=0;j<arr.size()-i-1;j++){

            //if elements are in wrong order, swap them
            if(arr[j] > arr[j+1]){

                swap(arr[j], arr[j+1]);

            }

        }

    }
}


Note: (arr.size() - i - 1) is used to avoid comparing already sorted elements at the end.


DRY RUN:
--------

Let's say arr = {5, 3, 1, 4}

Size n = 4

Pass (i)	j range					Explanation

i = 0		j = 0 to 2 (0 to n - i - 2)		Compare first 3 elements, bubble max to end

i = 1		j = 0 to 1				Last element is sorted, so check first 2 only

i = 2		j = 0					Only need to compare first 2 elements

i = 3		Done					All sorted, loop ends





To sort in descending order:
---------------------------

Just change the condition (arr[j] > arr[j+1]) to (arr[j] < arr[j+1])

Time Complexity:  wrost and avg case: O(n^2)
Space complexity: O(1)


If supplied array is already sorted, the above approach will take O(n^2), it still perform multiple pass.
In this case to optamise the above code, we need to skip the outer loop and then we can get the time complexity at best case O(n)



void bubbleSort(vector<int>& arr){


    //outer loop for each pass
    for(int i=0;i<arr.size()-1;i++){


        // Flag to check if any swap happened in this pass
        bool swapped = false;

        //inner loop for compare adjacent elements
        for(int j=0;j<arr.size()-i-1;j++){

            //if elements are in wrong order, swap them
            if(arr[j] > arr[j+1]){

                swap(arr[j], arr[j+1]);
                swapped = true;
            }

        }

        // If no elements were swapped, array is already sorted
        if (!swapped)
            break;

    }


}


Advantage:
----------

1. Simple to understand and implement:

--It’s one of the easiest sorting algorithms to learn.
--Great for beginners to understand the basics of sorting.

2. In-place algorithm:

–-No extra space is required. Sorting is done using the original array.
–-Space complexity is O(1) (constant space).

3. Stable sort:

--It preserves the relative order of equal elements.
--Example: If you have two 5, the one that came first will still come first after sorting.


Disadvantage:
--------------

1. Very inefficient for large data:

--Worst and average case time complexity is O(n²).
--Not suitable for large datasets.

2. Rarely used in practice due to poor performance.





Selection Sort:
================

Concept:
--------

--In Selection Sort, we find the smallest (or largest) element from the unsorted part of the array and swap it with the element at the beginning of the sorted part.

--This process continues until the array is completely sorted.

--It always "selects" the minimum (or maximum) and puts it in its correct position, one at a time.


Step-by-Step Procedure:
-----------------------

1. Start from the 0th index (let’s call it the current index).

2. Find the smallest element in the subarray from the current index to the end.

3. Swap the found minimum with the element at the current index.

4. Move to the next index and repeat steps 2–3 until the end.


Analogy:
---------
Imagine you're picking players for a team:
--You scan the group to find the shortest player and place them first.
--Then, from the remaining players, find the next shortest and place them second, and so on.


 
Example:
--------

Let’s sort: arr = [5, 3, 1, 4] (ascending order)


Step 1:

--Find min in [5, 3, 1, 4] => 1
--Swap 1 with arr[0] → [1, 3, 5, 4]

Step 2:

--Find min in [3, 5, 4] => 3
--Swap 3 with arr[1] → [1, 3, 5, 4] (already in position)

Step 3:

--Find min in [5, 4] => 4
--Swap 4 with arr[2] → [1, 3, 4, 5]
 
Step 4:

--Last element is already in correct place

Final result: [1, 3, 4, 5]



Code:
-----


void selectionSort(vector<int>& arr){

    //Outer loop for each position
    for(int i=0;i<arr.size()-1;i++){

        //assume the current index is the minindex
        int minindex= i; 

        //inner loop to find the actual minindex
        for(int j=i+1; j< arr.size();j++){

            if(arr[j] < arr[minindex]){
                minindex = j;
            }

        }

        //swap the found minimum with the element at i
        if(minindex != i){
            swap(arr[i], arr[minindex]);
        }
    }

}


--Here the outer loop will run total n-1 times, because at each iteration we place one element in the correct place, so after (n-1) iterations, the last element (arr[n-1]) is automatically placed in the correct place, so there is no need to compare it anymore.


--At the last we checked if(minindex != i), it checks:

Is the current element already the minimum?
If yes, then no need to swap — just skip it.

Without this if condition, still our code will work but it's wastefull. so for better optamization checked this condition. 

swap(arr[0], arr[min])//// Useless operation


For descending order: just revese the following condition:
if (arr[j] < arr[minIndex]) 

to

(arr[j] > arr[minIndex]) //descending order

And rename minIndex to maxIndex (for clarity).

Time complexity:  for the best and worst case will be O(n^2)
for the best case(if array is already sorted) still scan all the elements for min.

Space Complexity: O(1)





Advantage:
----------

1. Simple to understand and easy to implement:

--Like Bubble Sort, it's very easy to code and explain.
--Good for learning the concept of sorting.

2. Good for small arrays (n ≤ 50).

3. In-place sorting (no extra memory).




Disadvantage:
-------------

1. Inefficient for large arrays:

--Time complexity is O(n²) for all cases (best, average, and worst).
--Not practical for sorting large datasets.


2. Unstable sort:

--Relative order of equal elements is not preserved.
--Example: If you have two 5, their order might change after sorting.


3. No early stopping:

--Unlike Bubble Sort, it doesn’t detect if the array is already sorted.
--It always goes through all elements even if the array is already sorted.







Insertion Sort:
===============


Concept:
--------

--Insertion Sort builds the sorted array one element at a time.

--It picks the current element and inserts it into its correct position among the already sorted part of the array (on the left).


Analogy:
--------

Arranging playing cards in hand:

1. Take one card at a time from the deck.

2. Compare it with cards already in your hand (which are sorted).

3. Insert it into the correct position by shifting other cards.



Step-by-Step Procedure:
------------------------

1. Assume the first element (index 0) is already sorted.

2. Start from index 1.

3. Take arr[i] as the key.

4. Compare key with previous elements.

5. Shift all greater elements to the right.

6. Insert the key in its correct place.



Example:
---------

Let’s sort: arr = [5, 2, 4, 6] (ascending order)

Step 1: 

Start the index i with 1 and store its value in a variable called "key".

key=arr[1] => 2

Now compare 2 with the previous elements to find the correct position.

--compare 2 with 5 => 2 is smaller => shift one step to the right
--Now insert 2 in the empty spot (at index 0)

result: [2,5,4,6]

Step 2:

i = 2, key = 4

We compare 4 with the previous elements (5 and 2)

--compare 4 with 5 => 4 is smaller => shift 5
--compare 4 with 2 => 4 is bigger  => stop and insert 4 here (after 2)

result: [2,4,5,6]


Step 3: 

i = 3, key = 6

We compare 6 with previous elements (5, 4, 2)

--6 is greater than all of them, so it's already in the right place

Final Sorted Array: [2, 4, 5, 6]



Code:
-----


void insertionSort(vector<int>& arr){


    for(int i=1; i<arr.size(); i++){

        //store the second element as key
        int key = arr[i];

        //points to the prev element
        int j=i-1;

        // Shift elements that are greater than key
        while(j>=0 && arr[j] > key){

            // Shift the larger elements
            arr[j+1] = arr[j];
            j--;
        }


        //insert the key to the empty spot (at the correct position)
        arr[j+1] = key;

    }


}


For Descending order: Just reverse the following comparison:

while (j >= 0 && arr[j] < key)


Time complexity: 
--Wrost case: O(n^2): maximum number of shifts.
--Best case: If array is already sorted, Only one comparision per element: O(n)

Space complexity: O(1)



Advantage:
----------

1. Simple and easy to understand:

--The logic is intuitive and easy to implement for beginners.

2. Efficient for small or nearly sorted arrays:

--Time complexity can be as good as O(n) if the array is already sorted or nearly sorted.
--Faster than Bubble Sort and Selection Sort in such cases.

3. In-place sorting:

--It doesn’t use any extra space.
--Space complexity is O(1).

4. Stable Sort:

--It maintains the relative order of equal elements.
--This is useful when sorting data with multiple fields (e.g., sorting by name and age).


Disadvantage:
-------------

1. Slow for large datasets

--Time complexity is O(n²) in the worst case (e.g., reverse sorted array).
--Not suitable for large datasets.


vector<int> merge(vector<int>& arr1, vector<int>& arr2){


}













Merging the 2 sorted arrays:
=============================

vector<int> arr1= {4,6,8,12,15};

vector<int> arr2= {3,4,9,18,20};




Using Brute force:
------------------

Steps:
------

1. Create a new array.

2. Add all elements from the first array to it.

3. Add all elements from the second array to it.

4. Sort the final array.

5. Done!


Time complexity:
----------------

1. Copying arr1 and arr2 into result array:

Time: O(n + m)

2. Sorting the combined array of size (n + m):

Time: O((n + m) * log(n + m))


Final Time complexity: O((n + m) * log(n + m))

Space Complexity: O(n + m) for merged array


Optamized  approach:
--------------------

Step-by-Step Logic (Two-Pointer Approach):

1. Create an empty result array to store the merged values.

2. Use two pointers: i=0 for arr1, and j=0 for arr2.

3. While both pointers are within bounds of their arrays: while(i< arr1.size() && j< arr2.size())

	--Compare arr1[i] and arr2[j].

	--Insert the smaller value into the result array.

	--Move the pointer of the array from which the smaller value was taken.

4. After the loop, one of the arrays might still have leftover elements.

5. Add the remaining elements from arr1 (if any) to the result.

6. Add the remaining elements from arr2 (if any) to the result.

7. Done– you now have one merged sorted array.


code:
-----


vector<int> getMergedArray(vector<int>& arr1, vector<int>& arr2){

vector<int> result;

int i=0;
int j=0;


//step1: compare and merge
while(i < arr1.size() && j < arr2.size()){

    if(arr1[i] < arr2[j]){
        result.push_back(arr1[i]);
        i++;
    }else{

        result.push_back(arr2[j]);
        j++;
    }
}


//step2: add the remaining elements if any from arr1
while(i < arr1.size()){
    result.push_back(arr1[i]);
    i++;
}

//step3: add the remaining elements if any from arr2
while(j < arr2.size()){
    result.push_back(arr2[j]);
    j++;
}

return result;

}



Time Complexity: O(n + m) (where n and m are lengths of the arrays)

Space Complexity: O(n + m) (for storing merged array)




Merge Sort:
============


--Merge sort also uses the divide and conquer approach.

Divide: Split the array into 2 halves
conquer: sort each half recursively.
combine: Merge the two sorted halves into one.


Analogy:
-------

Imagine you're sorting a deck of cards. You:

--Split the deck in half again and again until each pile has 1 card.

--Then, merge two small sorted piles into one sorted pile.

--Continue until all cards are in one sorted pile.



Steps:
-------

1. If the array has 1 element, it is already sorted.
2. Otherwise:

--find the middle of the array
--split the array into left half and right half.
--recursively apply Merge sort to both halves.
--merge the both sorted halves.



Example Step by step process:
-----------------------------

Let’s say arr = [5, 2, 8, 3]:

It splits into [5, 2] and [8, 3]

Then further into [5] [2] and [8] [3]

Then merges [5] [2] → [2, 5] and [8] [3] → [3, 8]

Final merge: [2, 5] and [3, 8] → [2, 3, 5, 8]



Code: (Not In-place version)
------

//Merge function
vector<int> merge(vector<int> arr1, vector<int> arr2){

vector<int> result;

int i=0;
int j=0;


while(i< arr1.size() && j< arr2.size()){

if(arr1[i] < arr2[j]){

    result.push_back(arr1[i]);
    i++;

}else{
    result.push_back(arr2[j]);
    j++;
}

}


while(i < arr1.size()){
    result.push_back(arr1[i]);
    i++;
}

while(j < arr2.size()){
    result.push_back(arr2[j]);
    j++;
}


return result;

}


//Merge sort function
vector<int> mergeSort(vector<int> arr){

    //base condition
    if(arr.size() <= 1){
        return arr;
    }

    //find the middle
    int mid = arr.size()/2;


    //split the array into two halves
    vector<int> left;
    vector<int> right;

    for(int i=0; i< mid;i++){
        left.push_back(arr[i]);
    }

    for(int i=mid; i< arr.size();i++){
        right.push_back(arr[i]);
    }

    //vector<int> left(arr.begin(), arr.begin()+mid);
    //vector<int> right(arr.begin()+mid, arr.end());


    //recursivly sort both halves
    left = mergeSort(left);
    right = mergeSort(right);


    //merge the sorted halves
    return merge(left, right);

}



Above example with debug:
===========================


#include <iostream>
#include <vector>
using namespace std;

// Merge two sorted arrays
vector<int> merge(vector<int> arr1, vector<int> arr2) {
    vector<int> result;
    int i = 0, j = 0;

    cout << "Merging: [";
    for (int a : arr1) cout << a << " ";
    cout << "] and [";
    for (int b : arr2) cout << b << " ";
    cout << "]\n";

    // Merge process
    while (i < arr1.size() && j < arr2.size()) {
        if (arr1[i] < arr2[j]) {
            result.push_back(arr1[i]);
            i++;
        } else {
            result.push_back(arr2[j]);
            j++;
        }
    }

    // Append remaining elements
    while (i < arr1.size()) {
        result.push_back(arr1[i]);
        i++;
    }

    while (j < arr2.size()) {
        result.push_back(arr2[j]);
        j++;
    }

    // Print merged result
    cout << "Merged Result: [";
    for (int x : result) cout << x << " ";
    cout << "]\n\n";

    return result;
}

// Merge Sort function
vector<int> mergeSort(vector<int> arr) {
    // Base case
    if (arr.size() <= 1) {
        return arr;
    }

    int mid = arr.size() / 2;

    // Split into left and right
    vector<int> left(arr.begin(), arr.begin() + mid);
    vector<int> right(arr.begin() + mid, arr.end());

    // Debug: Show current split
    cout << "Splitting: [";
    for (int x : arr) cout << x << " ";
    cout << "] into\n   Left: [";
    for (int x : left) cout << x << " ";
    cout << "] and Right: [";
    for (int x : right) cout << x << " ";
    cout << "]\n\n";

    // Recursive sort
    left = mergeSort(left);
    right = mergeSort(right);

    // Merge sorted halves
    return merge(left, right);
}

// Driver code
int main() {
    vector<int> arr = {10, 3, 5, 2, 8, 7, 1, 6, 4, 9};

    cout << "Original Array: [";
    for (int x : arr) cout << x << " ";
    cout << "]\n\n";

    vector<int> sorted = mergeSort(arr);

    cout << "\nSorted Array: [";
    for (int x : sorted) cout << x << " ";
    cout << "]\n";

    return 0;
}





DRY RUN: Merge sort
====================

Input arr: {6, 3, 8, 5, 2}


Step by step Reccursive spliting:

			[6,3,8,5,2]
			      |
	-------------------------------------------------
	|						|	
      [6,3]					     [8,5,2]
        |						|
------------------			-------------------------
 |		|			|			|	
[6]	       [3]		       [8]		      [5,2]
								|
							------------------
							|		 |
						       [5]		[2]	





Then merging happens bottom up:

[6] + [3] => [3,6]
[5] + [2] => [2,5]
[8] + [2,5] => [2,5,8]
[3,6] + [2,5,8] => [2,3,5,6,8]










Time Complexity:
----------------

1. Divide step:

--Each time we split the array into two halves.
--It takes O(1) time to divide
--But how many times we divide ?

	--if array has n elements, we can divide it logn times.
	--Why?, Because every time we divide it into 2, like:
		n => n/2 => n/4, --- => 1
		This gives logn levels.
		for n = 5, log(5) =~ 2.3 around 3 level deep.





2. Merge step:

--After dividing, we merge the elements back
--At each level,  we merge  n  elements total.

so,

Time per level: O(n)
Number of levels: O(log n)

Total time = O(n log n)

 
Space complexity:
-----------------

--Merge Sort needs extra space to store temporary arrays during the merge step.

--If the input size is n, then: Temporary arrays might take up to O(n) space.





Space complexity: O(n)



Modify the above example: In-place index Merge Sort (Modify the original array instead of returning new one)
--------------------------


arr = [10,20,30,40,12,25,38,68];



// Merge function to merge two sorted halves in-place
void merge(vector<int>& arr, int start, int end, int mid){

    vector<int> temp;


    int i=start;
    int j= mid+1;

    //compare and merge elements
    while(i <= mid && j<=end){

        if(arr[i] < arr[j]){
            temp.push_back(arr[i]);
            i++;
        }else{
            temp.push_back(arr[j]);
            j++;
        }
    }

    //copy remaning elements from left half
    while(i <= mid){
        temp.push_back(arr[i]);
        i++;
    }

    //copy remaining elements from right half
    while( j<= end){
        temp.push_back(arr[j]);
        j++;
    }

    //copy merged elements back to the original array
    for (int k = 0; k < temp.size(); k++) {
	
        arr[start+k] = temp[k];
    }



}

void mergeSort(vector<int>& arr, int start, int end){

    if(start >= end)
        return;

    int mid= (start+end) /2;

    //recursivly sort the left and right halves
    mergeSort(arr, start, mid);
    mergeSort(arr, mid+1, end);

    //Merge the sorted halves
    merge(arr, start, end, mid);


}




int main(){

    vector<int> arr={10,2,5,8,7,0,-1,5};

    int start =0;
    int end= arr.size()-1;

    // call the mergeSort by passing arr, start index and end index
    mergeSort(arr,start, end);

    for(int i: arr){
        cout<<i <<" ";
    }
    
    
    
    return 0;
    
}


Explanation:
--------------

1. the merge function will break the array into the two halves.

2. merge(arr, start, end): The start and end values change in each recursive call and represent the part of the array currently being sorted.

3. 'start' will maintain the original array index while copying from temp array in each recursive call.







Advantages of Merge Sort:
------------------------

1. Fast and Efficient: Always runs in O(n log n) time — better than Bubble, Insertion, and Selection Sort for large datasets.

2.  Stable Sort: Maintains the original order of equal elements (important for sorting complex data).

3. Good for Linked Lists: Works very well with linked lists (unlike quicksort which requires random access).

4. Predictable Performance: Performance does not degrade in worst-case (unlike Quick Sort).


Disadvantage:
-------------

1.  Uses Extra Space: Requires O(n) extra memory for merging arrays, which is a big drawback in memory-constrained environments.

2. Not In-Place: In version 1.

3. Slower for Small Arrays: For very small arrays, simpler algorithms like Insertion Sort can be faster.

4. More Complex to Code: Slightly harder to implement than simpler sorts like Bubble or Selection Sort.



Quick Sort:
============


--Quick Sort is called “quick” because, on average, it performs faster than most other sorting algorithms like bubble sort, insertion sort, or even merge sort in practical scenarios for large datasets with less memory overhead.

--Here Name is quick, but it is not the fastest method for sorting.


--Quick sort is a "Divide and conquer" algorithm that picks a pivot element, partitions the array around it, and recursively sorts the subarrays. 

Divide and conquer: Split the problem into smaller sub-problems and conquer it by solving the smaller sub-problems.



--The main key concept in the merge sort is the "merging" procedure.
--similarly the key concept for the quick sort is the "partition" procedure.


Partition: 
-----------

--In this procedure we choose one element from an array as a 'pivot' element and perform partition around this pivot element
(arranging the smaller element to the left side of this pivot and bigger element to the right side of this pivot element).


--And need to repeat this process recursively on the both side untill the whole array is sorted.


--we can choose the pivot element as any element from an array, but generally we take the pivot as either first or last or a middle or any random element.

--most of the quick sort algorithm follows either first or last element.



Analogy:
---------

--Imagine you're arranging books of different sizes on a shelf.

--You pick one random book (say, the pivot) and want to rearrange such that:

--->All smaller books go to its left.

--->All bigger books go to its right.

--Then you repeat the same process recursively on the left side and right side until all the books are sorted.
 
 
**Note: Quick sort works on the idea for, if for an element all the smaller elements are on its left side and bigger elements are on its right side then that element is called as a sorted element.



Example:

        0   1  2   3  4   5  6  7  8
arr = {10, 16, 8, 12, 15, 6, 3, 9, 5}


lets take the first element arr[0] = 10 as pivot

--Now we need to find the sorted position of this pivot(10) element, such that all the smaller element moves its left side and all the bigger elements should moves its right side.


int partition(vector<int>& arr){


}



here we take 2 pointers

i = start+1; (points to where the next smaller element should go)
j = start+1; (traverse the array)


--whenever we find arr[j] < pivot, we swap arr[i] and arr[j] and move i forward.

--finally, we swap pivot(arr[start] with arr[i-1]) to put it in the right position.



code for partition: 
--------------------


#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int start, int end){

    int pivot = arr[start];

    int i=start+1;

    for(int j=start+1; j<=end;j++){

        if(arr[j] < pivot){
            swap(arr[i], arr[j]);
            i++;
        }

    }

    swap(arr[start], arr[i-1]);
    return i-1; //pivot's correct position


}


int main(){

    vector<int> arr={10, 16, 8, 12, 15, 6, 3, 9, 5};
    
    int start=0;
    int end=arr.size()-1;

    cout<<partition(arr, start, end);
    cout<<endl;

    cout<<"After partitition the element" <<arr[start] <<"placed to the correct position" <<endl;
    for(int i:arr){
        cout<<i <<" ";
    }

    
    
    return 0;
    
}



--once we done the first partition, we will receive the correct index position for the first pivot element.
--now we need to recursively perform the same operation of the left and right side of the result index

left part:  start, pivotIndex-1;
right part: pivotIndex+1, end

till the start >= end



code for quick sort:
-----

void quickSort(vector<int>& arr, int start, int end){

//Base case: 0 or 1 element => already sorted
if(start >= end)
	return;

int pivotIndex = partition(arr, start, end);


//recursive call
quickSort(arr, start, pivotIndex-1);
quickSort(arr,pivotIndex+1, end);


}


final code:
-----------

 
#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int start, int end){

    int pivot = arr[start];

    int i=start+1;

    for(int j=start+1; j<=end;j++){

        if(arr[j] < pivot){
            swap(arr[i], arr[j]);
            i++;
        }

    }

    swap(arr[start], arr[i-1]);
    return i-1; //pivot's correct position


}


void quickSort(vector<int>& arr, int start, int end){

//Base condition
if(start >= end)
	return;

int pivotIndex = partition(arr, start, end);


//recursive call
quickSort(arr, start, pivotIndex-1);
quickSort(arr,pivotIndex+1, end);


}


int main(){

    vector<int> arr={10, 16, 8, 12, 15, 6, 3, 9, 5};
    
    int start=0;
    int end=arr.size()-1;

    quickSort(arr, start,end);

    //printing the result
    for(int i:arr){
        cout<<i <<" ";
    }    
    
    return 0;
    
}



Time complexity:
-------------------

1. Partition function:

--The partition function runs a single loop from start+1 to end, so: O(n)


2. Quick Sort function:

--here 2 recursive calls are made after each partition 

a. subarray before the pivot: start to pivotIndex-1
b. subarray after the pivot: pivotIndex+1 to end

Best case: 

--pivot always splits into 2 equal halves.

--each one with n/2, n/4,... O(logn) + O(logn) => O(2logn) => O(logn)

--so the total time complexity for the Best case will be:

O(n) for partition * O(logn) for quick sort => O(n* logn)


--Each level of recursion processes all n elements during partitioning (O(n)), 
--and there are log n levels if splits are balanced → Total = O(n log n)


Wrost case: (Already sorted or reverse-sorted array, pivot is always smallest/largest)

In this case:

--one side of the partition has size n-1 and the other side will be 0.

--in this case the total time complexity for the quick sort will be:
O(n) for partition * O(n) for recursive call => O(n^2)

Space complexity for the Quick sort:
------------------------------------

For Partition:

--No extra space or vector is used for partitioning (Unlike merge sort)
so, O(1) (In-place partitioning)

For Quick sort:

--At each level, recursive calls are added to the function call stack.
--so the depth of the recursion:

Best case: O(logn)
Wrost case: O(n)


Note: we can minimize the risk the wrost case Time and Space complexity by avoiding to choosing the pivot element as first or last element, and taking it as Random element.



Randomized Pivot (Best in Most Cases):
--------------------------------------

Idea: Pick a random index between start and end, and use that element as the pivot.

Why: This helps reduce the chance of worst-case performance (O(n²)), especially for sorted or nearly sorted arrays.

Performance: Average time complexity remains O(n log n) in most scenarios.

Recommended when:

--The input array is large

--You want consistent average performance


steps:

step 1: choose the random pivot:

int randomIndex = rand() % (end - start + 1) + start;

step2: swap this randomIndex element with the first index element

step3: perform the same as above code.



Final Code for randomized pivot:
--------------------------------

#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int start, int end){

    //get the random index
    int randomIndex= rand() % (end-start+1)+start;
    //cout<<"Random index is: "<<randomIndex <<endl;

    //swaping it with the first index element
    swap(arr[start], arr[randomIndex]);


    int pivot = arr[start];

    int i=start+1;

    for(int j=start+1; j<=end;j++){

        if(arr[j] < pivot){
            swap(arr[i], arr[j]);
            i++;
        }

    }

    swap(arr[start], arr[i-1]);
    return i-1; //pivot's correct position


}


void quickSort(vector<int>& arr, int start, int end){

//Base condition
if(start >= end)
	return;

int pivotIndex = partition(arr, start, end);


//recursive call
quickSort(arr, start, pivotIndex-1);
quickSort(arr,pivotIndex+1, end);


}


int main(){

    vector<int> arr={10, 16, 8, 12, 15, 6, 3, 9, 5};
    
    int start=0;
    int end=arr.size()-1;

    quickSort(arr, start,end);

    for(int i:arr){
        cout<<i <<" ";
    }
    
    return 0;
    
}


Choosing partition as last index: 
---------------------------------

we can also use the similar strategy as above taking the last index element as pivot and swap it with the first index element and perform the similar operation on partition.




Lomuto Partition:
------------------


Note: For choosing the last index we can also perform "Lomuto Partition". It was introduced by Nico Lomuto, a computer scientist.

--It was popularized through the book "Programming Pearls" by Jon Bentley, where it was used to explain how Quick Sort works.

--It generally picks the last element as the pivot.

--Good for learning and understanding how quick sort divides arrays.



Code:
-------

int partition(vector<int>& arr, int start, int end) {
    int pivot = arr[end];  // pivot as last element
    int i = start - 1; //invalid position before first element

    for (int j = start; j < end; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }

    swap(arr[i + 1], arr[end]);  // place pivot at correct position
    return i + 1;
}




Choosing a random pivot + starting from first element is usually better than using Lomuto with the last element.


Quick Sort vs Merge Sort:
=========================

Feature					Quick Sort				Merge Sort

1. Time complexity:Best and avg case:	O(n log n)				O(n log n)

2. Time complexity:Wrost:		O(n^2) if pivot in badly choosen	O(n log n) always

3. Space complexity:			O(log n) (in-place)			O(n) extra space is needed for merging

4. Stable ?				Not stable				Stable





Quick Sort is better when:
--------------------------

--You're sorting in-memory (array in RAM).
--You want faster average-case performance.
--You want in-place sorting (less memory).
Example: Sorting huge array of integers in RAM (like in competitive coding or game engines).	


Merge Sort is better when:
--------------------------

--You need stable sorting (equal elements remain in order).
--You're dealing with linked lists.
--You're working with external sorting (e.g., large files on disk).
--You want predictable performance regardless of input.
Example: Sorting huge files on disk, or sorting based on multiple criteria (like stable name sorting in contacts).



Analogy:
--------

--Quick Sort is like a fast but moody chef — when they get it right (good pivot), they’re super fast! But a bad mood (bad pivot) slows everything down.

--Merge Sort is like a robot — consistent and stable, but needs more space to work.

so, finally:

--If you care about speed and space → Go for Quick Sort (with randomized pivot for safety).
--If you care about stability and consistency → Use Merge Sort.



Note: The C++ Standard Library std::sort() does not use pure Quick Sort or Merge Sort.

Instead, it uses a hybrid sorting algorithm called: IntroSort (Introspective Sort)

What is IntroSort?

--It starts with Quick Sort (for speed).
--If recursion goes too deep (i.e., pivot is bad → worst-case O(n²)), it switches to Heap Sort.
--For small parts (like fewer than 16 elements), it may use Insertion Sort (super-fast for tiny arrays).










 




























