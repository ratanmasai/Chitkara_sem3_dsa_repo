LinkedList:
===========

A Linked List is a linear data structure where elements (called nodes) are not stored in contiguous memory like arrays.

Each node contains:

1. Data

2. Pointer (or reference) to the next node

Unlike arrays, linked lists do not have fixed size and do not require elements to be stored next to each other in memory.




Basic Node Structure:
=====================

structure based Node:
---------------------

struct Node {
    int data;
    Node* next;
};


class based Node:
-----------------

class Node {
public:
    int data;
    Node* next;

    //constructor
    Node(int data) {
        this -> data = data;
        this -> next = NULL;
    }
};



Types of Linked Lists:
======================

Linked List are of 3 types:
---------------------------

1. Singly Linked List:

--Each node has data + pointer to next node.

--One-directional.

Example:

A → B → C → NULL


2. Doubly Linked List: 

--Each node has:

a. Data

b. Pointer to next

c. Pointer to previous

--Two-directional


Example:

NULL ← A ⇄ B ⇄ C → NULL



3. Circular Linked List:

--Last node points back to the first node

--Can be singly or doubly circular

Example:

A → B → C
  <-  <-
↑       ↓
←←←←←←←←←





Characteristics of Linked Lists:
---------------------------------

1. Dynamic size: Can grow/shrink at runtime

2. Efficient insertions/deletions: Especially at beginning/middle

3. No direct access: Must traverse from head to find a node

4. Memory-efficient: Allocates memory as needed

5. Useful for implementing stacks, queues, graphs, hash maps, etc.







Array vs Linked List:
=======================


Feature				Array/Vector				Linked List

1. Size				Fixed(array), auto(vector)		Dynamic, no need to define in advance

2. Memory Allocation		Contiguous				Non-Contiguous(Nodes will be created in Heap)

3. Insertion/Deletion		Costly (shift elements)			Fast(no shifting, just change the pointers)

4. Access time			Fast (O(1) via index)			Slow, O(n), no index.

5. Memory Efficiency		Can waste memory			Efficient if many insertion/deletions

6. Random Access		Yes					No



Advantages Over Arrays:
-----------------------

--Dynamic resizing (add/remove nodes easily).
--Efficient insertions/deletions (O(1) if position is known).
--No memory waste (only allocate needed nodes).

Disadvantages:
---------------

--No random access (O(n) to access nth element).
--Extra memory for pointers.
--Not cache-friendly (non-contiguous memory).



Real-Life Analogy
-----------------

--Imagine a train:

--Each bogie (coach) is like a node.

--Every bogie is connected to the next one via a connector.

--You can move coach to coach, but you don’t know the exact position unless you traverse from the start.

Just like:

Node = bogie

next = connector to next bogie

head = engine (starting point)



Head Node:
-----------

--It is a pointer which points to the first node only inside the Linked List, with this Head pointer only we traverse the entire LinkedList, we can also maintain a Tail Pointer as well to point the last element.





LinkedList class Defination:
===========================

class LinkedList{

private:

	Node* head;


public:

	//constructor 
	LinkedList(){

		//empty LinkedList
		head = NULL;

	}


//All operations will go here..

}




Traversing a Linked List:
-------------------------

--Traversal means visiting each node in the linked list, typically to process or display data, starting from the head and following the next pointers.

Steps:

1. Start at the head node.
2. While the current node is not nullptr:
	--Process the node’s data (e.g., print it).
	--Move to the next node using the next pointer.
3. Stop when reaching nullptr.

Traversal Analogy:
------------------

Walking through a treasure hunt:

--Start at the first clue (head).
--Read each clue (data) and follow the arrow (next pointer) to the next clue.
--Stop when there’s no more clues (nullptr).









Basic Operations: Insert at begining and display(traverse over each nodes)
==================

#include <iostream>
#include <vector>
using namespace std;

class Node{

public:
    int data;
    Node* next;

    //constructor
    Node(int data){
        this -> data = data;
        this -> next= NULL;
    }


};


class LinkedList{

private:

    //head stores the address of the first node.
    Node* head;

public:

    //constructor 
    LinkedList(){

	//empty list
        head= NULL;
    }

    //insertion at the begining
    void insertAtBegining(int value){

        //creating a new node object with the data
        Node* newNode = new Node(value);

	//if the list is empty
	if(head == NULL){
		head = newNode;
	}else{

        	//linking the existing node with the new node
	        newNode->next = head;

        	//making the newNode as head
        	head=newNode;
	}

    }

    //display the LinkedList
    //Prints all elements from head to the end.
    void display(){

	if(head == NULL){
      		cout << "Linked List is empty." << endl;
        	return;
    	}

        Node* temp = head;
        while(temp != NULL){
            //getting the data from the node
            cout<<temp->data <<" -> ";
            //moving to the next node.
            temp=temp->next;
        }
	cout << "NULL" << endl;

    }




};


int main(){


    LinkedList ll;

    ll.insertAtBegining(10);
    ll.insertAtBegining(5);
    ll.insertAtBegining(2);
    ll.insertAtBegining(1);

    ll.display();


    return 0;
    
}




The time complexity for adding a new Node at the begining is: O(1)
and for the traversing all the nodes for display is: O(n)


Note: Adding a destructor to your LinkedList class is an excellent practice. It ensures that when a LinkedList object goes out of scope, all dynamically allocated memory (the nodes) is properly released, preventing memory leaks.


Q/- Why Destructor?

At the time of:

Node* newNode = new Node(value);

--We allocate memory on the heap. This memory must be manually deallocated using delete. Otherwise, it will create a memory leak.

Add Destructor to the above Class:



    //Destructor to free up heap memory and prevent memory leaks
    ~LinkedList(){

        Node* currentNode = head;
        while(currentNode != NULL){

            //store the next node into the temp Node.
            Node* nextNode= currentNode->next;
            //Free memory of the current node
            delete currentNode;
            //move to the next node
            currentNode = nextNode;


        }
	//reset the head and tail(if any) to NULL (good practice)
	head = NULL;


    }


--When the program ends or the LinkedList object goes out of scope, the destructor is automatically called. Without it, the new keyword will keep memory on the heap, causing memory leaks, especially if thousands of nodes are created during runtime.





Inserting at Last/end:
======================


Logic :


1. Create a new Node with the given value
2. If the list is empty (head == NULL), set the head = newNode
3. Otherwise:
	--Traverse to the last node (temp -> next != NULL)
	--Set the last node's next to point to the new node.


Code:
------


  void insertAtLast(int value){

            //creating new Node
            Node* newNode = new Node(value);

     //Case1: Empty List
            if(head == NULL){
                head = newNode;
             
            }else{

	
     //Case2: Traverse to the end
            Node* temp= head;
            while(temp->next != NULL){
                temp= temp->next;
            }

     //Link the Last node to newNode
            temp->next = newNode;
    }
     }




Note: For the adding new Node to the end the Worst case Time complexity will be O(n), To optamize this time complexity to O(1), we can make use of 2 pointers initially:

head node: points to the first Node
tail node: points to the last Node



So, when we insert at the end:

--Instead of looping to the end each time,

--we just connect tail->next = newNode and update tail = newNode.



Example:


class LinkedList{

    private:

        Node* head;
        Node* tail;

	int size;

    public:

        //constructor
        LinkedList(){
            head= NULL;
            tail= NULL;
	    size=0;
        }

        void insertAtBegining(int value){
            Node* newNode = new Node(value);
           
            if(head == NULL){
                head= newNode;
                tail = newNode;
            }
            else{
                newNode -> next = head;
                head = newNode;
            }

	     size++;
        }

        void display(){

            Node* temp= head;

            while(temp != NULL){
                cout<<temp->data <<" -> ";
                temp= temp->next;
            }
            cout<<"NULL" <<endl;

        }

        void insertAtLast(int value){

            //creating new Node
            Node* newNode = new Node(value);

            if(head == NULL){
                head = newNode;
                tail = newNode; 
            }else{
                    
                tail->next= newNode;
                tail = newNode;

            }
	
	    size++;

        }


};



Note: With the 2 pointers like head and tail we can improve the functionality of inserting and deleting an element from beginning or from end(Using doubly linked list) to the O(1) from the O(n).



Counting the elements:
======================

int getSize():

    return size;
}




Getting index of an item:
==========================

int indexOf(int val){

	int index=0;

	Node* current =head;

	while(current != NULL){

		if(current-> data == val){
			return index;
		}

		current =current-> next;
		index++;
	}

	return -1;

}



Check If LinkedList contains item:
---------------------------------


bool contains(int val){

	return indexOf(val) != -1;
}






Removing the first Item:
------------------------


void removeFirst(){

	if(head == NULL){

		cout<<"Linked List is empty \n ";
		return;
	}

	if(head == tail){

		delete head;
		head=tail = NULL;
	}else{

		Node* temp= head;
		head =head->next;
		delete temp; 
	}	
	
	size--;

}




To find the previous Node: (helper function)
---------------------------------------------

Node* getPrevious(Node* node){

	Node* current= head;

	while(current != NULL && current-> next != node){
		
		current = current -> next;
	}
	
	return current;


}







Remove the last item:
---------------------

void removeLast(){


	if(head == NULL){

		cout<<"Linked List is empty \n";
		return;
	}


	if(head == tail){

		delete head;
		head =tail = NULL;

	}else{

		Node* prev = getPrevious(tail);

		delete tail;
		tail= prev;
		tail->next = NULL;
	}	
	
	size--;
}



Getting the value at index:
---------------------------


    //getting the value at index
    int getValue(int index){

        if(index < 0 || index>size-1){
            cout<<"Invalid index \n";
            return -1;
        }

        Node* current= head;
        for(int i=0;i<index;i++){
            current = current->next;
        }

        return current->data;


    }





Getting array from a LinkedList:
--------------------------------


int* toArray(){

	int* arr = new int[size];

	Node* current = head;

	int i=0;

	while(current != NULL){

		arr[i++] =current ->data;
		current = current ->next;
	}

	return arr;
}



Inserting at any position:
--------------------------


Rules:

1. If index is 0, it's same as insertAtBegining:

2. If index is equal to size, its same as insertAtLast

3. If index is invalid (negetive or > size), print error.



void insertAt(int index, int value){


	if(index < 0 || index > size){

		cout<<"Error, Invalid index \n";
		return;
	}
	
	if(index == 0){

		insertAtBegining(value);
		return;
	}

	if(index == size){

		insertAtLast(value);
		return;
	}

	
	Node* newNode = new Node(value);
	Node* current = head;

	for(int i=0;i<index-1;i++){

		current = current -> next;
	}

	newNode -> next = current ->next;

	current-> next = newNode;

	size++;

}	




Delete from any position:
-------------------------

Rules:


1. If index is 0, call removeFirst()

2. If index is size-1, call removeLast()

3. If index is invalid (negetive or >= size), print error




void deleteAt(int index){

if (index < 0 || index >= size) {
        cout << "Error: Invalid index\n";
        return;
    }

    if (index == 0) {
        removeFirst();
        return;
    }

    if (index == size - 1) {
        removeLast();
        return;
    }

    Node* current = head;

    for (int i = 0; i < index - 1; i++) {
        current = current -> next;
    }

    Node* temp = current -> next;
    current -> next = temp-> next;
    delete temp;

    size--;


} 





Sorting a Linked List:
======================

Note: Since a Linked List is not indexed like an array, sorting it is not as straightforward. You can’t just use sort() like in arrays,
you must traverse, compare, and swap nodes or rebuild the list in sorted order.


Steps: Easiest way: 
-------------------

1. Convert a Linked List to an array

2. Sort the array using sort() inbuilt function

3. Clear the LinkedList

4. Re-insert elements from the sorted array


void sortLinkedList(){

	//if the LinkedList is empty or it has only one element.
	if(head == NULL || head->next ==NULL){
		return;
	}


	//step1: convert to array
	int* arr = toArray();


	//step2: sort the array
	sort(arr, arr+size);

	//Rebuild the LinkedList

	Node* current = head;

	int i=0;

	while(current != NULL){

		current->data = arr[i++];
		current = current-> next;
	}

	//free the heap memory
	delete[] arr;

}


Insertion in sorted LinkedList:
==============================

--In a sorted Linked List, we must insert elements while maintaining the sorted order (ascending or descending).

Example:

--If the list is: 10 → 20 → 30,

--and you insert 25, the new list becomes:

10 → 20 → 25 → 30




code:
-----


void insertSorted(int value) {
    Node* newNode = new Node(value);

    // Case 1: Empty list
    if (head == NULL) {
        head = tail = newNode;
    }

    // Case 2: New node should be inserted at beginning
    else if (value <= head->data) {
        newNode->next = head;
        head = newNode;
    }

    // Case 3: Insert somewhere in the middle or end
    else {
        Node* current = head;
        while (current->next != NULL && current->next->data < value) {
            current = current->next;
        }

        newNode->next = current->next;
        current->next = newNode;

        // Update tail if new node is inserted at the end
        if (newNode->next == NULL) {
            tail = newNode;
        }
    }

    size++;
}






Reversing a LinkedList:
========================


If your Linked List is:

10 → 20 → 30 → 40 → NULL


After reversing, it becomes:

40 → 30 → 20 → 10 → NULL

or

NULL <- 10 <- 20 <- 30 <- 40  // here 40 will become head




Logic:

--We maintain 3 pointers:

--prev → initially NULL

--curr → starts at head

--next → temporarily stores curr->next




code:
------


void reverse() {
    Node* prev = NULL;
    Node* current = head;
    Node* next = NULL;

    tail = head; // The current head will become tail

    while (current != NULL) {
        next = current->next;     // Step 1: Store next
        current->next = prev;     // Step 2: Reverse the pointer
        prev = current;           // Step 3: Move prev one step forward
        current = next;           // Step 4: Move current one step forward
    }

    head = prev; // Finally, update head
}








Final Time complexity of LinkedList:
====================================

1. Insert at beginning :   O(1)

2. Insert at end (w/o tail):  O(n)

3. Insert at end (with tail):  O(1)

4. Insert at any index:  O(n)

5. Delete from beginning:  O(1)

6. Delete from end: O(n):  need to traverse the prev of end element

7. Delete from index: O(n):

8. Search/indexOf:  O(n)

9. Display/traverse: O(n)

10. Reverse :  O(n)

11. Sort (via array):  O(n log n)



Slow and Fast Pointer in Linked List:
==================================


--The Slow and Fast Pointer technique (also called Tortoise and Hare) is one of the most powerful approaches to solving linked list problems efficiently.

--It uses two pointers:

1. Slow pointer → moves one step at a time.

2. Fast pointer → moves two steps at a time.


Why Use Slow and Fast Pointers?
----------------------------

--Instead of traversing the list multiple times or using extra memory, the slow–fast approach lets us solve problems in a single pass with O(1) extra space.



Applications of Slow–Fast Pointer:
---------------------------------

1. Finding the Middle of a Linked List:

--When the fast pointer reaches the end, the slow pointer will be at the middle.
--Useful in algorithms like splitting a list or merge sort.

2. Checking if a Linked List is a Palindrome:

--Move slow to the middle using slow–fast logic.
--Reverse the second half and compare with the first half.
--More efficient than using extra space.

3. Splitting a Linked List into Two Halves:

--The slow pointer ends up at the middle, dividing the list into two equal halves.
--Used in problems like Merge Sort on linked lists.

4. Detecting a Cycle in a Linked List (Floyd’s Algorithm):

--If there is a loop, the fast pointer will eventually meet the slow pointer.
--If no loop exists, the fast pointer will reach NULL.
--Used for detecting infinite loops before operations.



Example : Finding the Middle of a Linked List:
----------------------------------------


Method 1: Using size (Two-pass solution):

Idea:

--First calculate the total size of the linked list.

--Middle index = size / 2

--If size is even, this gives the second middle node (depends on implementation).

--Traverse again until that index and return the node.

code:
-----

Node* findMiddle() {
    int mid = size / 2;   // pre-maintained size variable
    Node* current = head;

    for (int i = 0; i < mid; i++) {
        current = current->next;
    }
    return current;
}




Method 2: Using Slow and Fast Pointers (One-pass solution):

Idea:

-Use two pointers:

--slow moves 1 step at a time.
--fast moves 2 steps at a time.

-When fast reaches the end:

--slow will be at the middle node.

--Since fast moves twice as fast, when it has traveled the whole list, slow has traveled only half the list → exactly the middle.

Step1: Initialize:

Node* slow = head
Node* fast = head

Step2: Traverse:

Move slow = slow->next
Move fast = fast->next->next

Step3: Stop when:

fast == NULL (even length list), OR

fast->next == NULL (odd length list).

At this point, slow is at the middle node.

Step4: return the slow.


code:
------


Node* findMiddle() {
    if (head == NULL) {
        return NULL;
    }

    Node* slow = head;
    Node* fast = head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;  // middle node
}






Example: Checking if a Linked List is Palindrome:
---------------------------------------------------------


--A Palindrome means a sequence that reads the same forward and backward.

Example: 1 → 2 → 3 → 2 → 1 is a palindrome, 
but 1 → 2 → 3 → 4 is not.



Approach1:
----------

Using extra space(array)

--convert the LinkedList into the array and then compare the first element with the last element and so on..
--this process is easy but it is not memory efficient.

Time complexity: O(n)
Space Complexity: O(n)

Code:
-----


bool isPalindromeUsingArray() {
    if (head == NULL || head->next == NULL) {
        return true; // Empty or single node list is palindrome
    }

    // Step 1: Copy elements into an array
    int* arr = toArray();

    // Step 2: Compare first and last elements
    int i = 0;
    int j = size - 1;
    while (i < j) {
        if (arr[i] != arr[j]) {
            delete[] arr;
            return false;
        }
        i++;
        j--;
    }

    delete[] arr; // Free allocated memory
    return true;
}





Approach2:
----------

--Using Slow and Fast pointer technique we can check the palindrome in-place without using extra space.

Steps:

1. Find the middle of the LinkedList

--Use the slow and fast pointer method.
--When fast reaches end, slow will be at the middle.

2. Reverse the second half of the list

--reverse the linked list from slow to end.

3. Compare the second half and the reversed second half

--traverse both halves and compare the data.

4. (Optional) Restore the list

--Reverse the second half again to restore the original order.


Code:
----

--Helper Function to Reverse a List (we already have reverse(), but we’ll use a local version for the second half)

Node* reverseList(Node* node) {
    Node* prev = NULL;
    Node* current = node;
    Node* next = NULL;

    while (current != NULL) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev; // New head of reversed list
}
 


Code for Palindrome Check:
-------------------------

bool isPalindrome() {
    if (head == NULL || head->next == NULL) {
        return true; // Empty or single node list
    }

    // Step 1: Find middle
    Node* slow = head;
    Node* fast = head;
    while (fast->next != NULL && fast->next->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Step 2: Reverse second half
    Node* secondHalfStart = reverseList(slow->next);

    // Step 3: Compare both halves
    Node* first = head;
    Node* second = secondHalfStart;
    bool palindrome = true;

    while (second != NULL) {
        if (first->data != second->data) {
            palindrome = false;
            break;
        }
        first = first->next;
        second = second->next;
    }

    // Step 4: Restore second half (optional, to keep list intact)
    slow->next = reverseList(secondHalfStart);

    return palindrome;
}



Cycle in LinkedList:
=====================

--A cycle (loop) in a linked list occurs when a node’s next pointer points back to a previous node instead of NULL.

--This creates an infinite loop because traversal will never reach NULL.

--If a cycle exists, the concept of a single tail breaks down.

--We can’t say tail->next = NULL directly, because we don’t know where the cycle starts and which node to call "tail."


Example:

1 -> 2 -> 3 -> 4
        ↑          |
        |_______|


Here, node 4 points back to node 2, so the list has a cycle.

code: create a cycle:
--------------------


 void createCycle() {
        if (head == NULL) return;

        Node* temp = head;
        Node* second = head->next; // storing 2nd node
        
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = second;  // Last node connects back to 2nd node
    }


Note: if we call display() method after this createCycle() method, it will form an infinite loop.



Floyd’s Cycle Detection Algorithm:
--------------------------------

It uses two pointers:

--slow (moves one step at a time)
--fast (moves two steps at a time)


Step1: Initialize:

slow = head;
fast = head;

Step2: Traverse the list:

Move: slow-> slow->next
Move: fast-> fast->next->next

Step3: Condition:

--if fast == NULL OR fast->next ==NULL ==> No Cycle
--if slow == fast ==> Cycle exists.

Example: DRY RUN:

List: 1->2->3->4->5->2 (loop)

Step1: slow=1, fast= 1
Step2: slow=2, fast= 3
Step3: slow=3, fast= 5
Step4: slow=4, fast= 3
Step5: slow=5, fast= 5 (they meet, cycle detected)


bool detectCycle() {

    if (head == NULL) return false;

    Node* slow = head;
    Node* fast = head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;          // move 1 step
        fast = fast->next->next;    // move 2 steps

        if (slow == fast) {
            return true; // Cycle found
        }
    }
    return false; // No cycle
}



Once Cycle is Detected:- Next Steps:

(A) Find the starting node of the cycle:

--find the node where the cycle begins.

code:
-----

Node* detectCycleStarts() {

    Node* slow = head;
    Node* fast = head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;          // move 1 step
        fast = fast->next->next;    // move 2 steps

        if (slow == fast) {
            break; // Cycle found
        }
    }
    
    //No Cycle
    if (fast == NULL || fast->next == NULL ) 
        return NULL;

    //Find Cycle start
    slow= head; //reset the slow to head
    while(slow != fast){
        slow= slow->next;
        fast = fast->next;
    }

    return slow; //start of cycle
    
}





(B) Remove the cycle

--Once we know where the cycle begins, we can break it by making the last node’s next = NULL

Steps:

1. First find the cycle’s starting node (using above method).

2. Then traverse from that node till you reach the last node in the cycle.

3. Make lastNode->next = NULL.


code:
------

void removeCycle() {

    Node* startOfCycle = detectCycleStart();
    if(startOfCycle == NULL) return;  // No cycle

    Node* temp = startOfCycle;
    while(temp->next != startOfCycle) {
        temp = temp->next;
    }
    temp->next = NULL; // Break the cycle
}



Merging two Linked List:
=========================

Problem Statement: 
-----------------

--We are given two linked lists, both are already sorted in ascending order.
--We need to merge them into a single sorted linked list.


Example:

List1: 1 → 3 → 5 → NULL
List2: 2 → 4 → 6 → NULL

MergedList = 1 → 2 → 3 → 4 → 5 → 6 → NULL


code:
------


Node* mergeTwoLists(Node* n1Head, Node* n2Head){


    //If first list is empty then return the second list
    // and if the second list is empty then return the first list
    //there is no use of merging.
    if(n1Head == NULL){
        return n2Head;
    }
        
    if(n2Head == NULL){
        return n1Head;
    }

    //step1: initliaze the head and tail for the merged List
    //Using tail node we add the new nodes(build the list)
    Node* head;
    Node* tail;

    if(n1Head->data < n2Head->data){
        head = tail = n1Head;
        n1Head= n1Head->next;
    }else{

        head = tail = n2Head;
        n2Head= n2Head->next;
    }


    //step2: Traverse and merge
    while(n1Head != NULL && n2Head != NULL){

        if(n1Head->data < n2Head->data){
            tail->next = n1Head;
            n1Head= n1Head->next;
        }
        else{

            tail->next = n2Head;
            n2Head= n2Head->next;
        }

        tail= tail->next;

    }


    //step3: attach the remaining nodes
    if(n1Head != NULL){
        tail->next= n1Head;
    }else{
        tail->next = n2Head;
    }

    return head;


};


int main(){


    LinkedList l1;
    l1.insertAtBegining(50);
    l1.insertAtBegining(40);
    l1.insertAtBegining(30);
    l1.insertAtBegining(20);


    LinkedList l2;
    l2.insertAtBegining(55);
    l2.insertAtBegining(42);
    l2.insertAtBegining(32);
    l2.insertAtBegining(22);

    Node* n= mergeTwoLists(l1.head,l2.head);

    while(n != NULL){
        cout<<n->data <<" -> ";
        n= n->next;
    }
    cout<<"NULL";

    

**Note: make the head and tail variable of the LinkedList class as public to run the above example.


DRY RUN:
--------

List1: 1 → 3 → 5
List2: 2 → 4 → 6


Process:

first compare(1,2) → 1 smaller → head=tail=1

then compare(3,2) → 2 smaller → tail->next=2

then compare(3,4) → 3 smaller → tail->next=3

then compare(5,4) → 4 smaller → tail->next=4

then compare(5,6) → 5 smaller → tail->next=5

Now List1 is empty → attach the remaining (6) of List2



Recursive approach:
--------------------

Node* mergeTwoLists(Node* n1Head, Node* n2Head) {
    // Base cases
    if (n1Head == NULL) return n2Head;
    if (n2Head == NULL) return n1Head;

    // Recursive step
    if (n1Head->data < n2Head->data) {
        n1Head->next = mergeTwoLists(n1Head->next, n2Head);
        return n1Head;
    } else {
        n2Head->next = mergeTwoLists(n1Head, n2Head->next);
        return n2Head;
    }
}


DRY RUN:
--------

List1: 1 → 3 → 5
List2: 2 → 4 → 6


Call 1:
mergeTwoLists(1, 2)
Compare 1 and 2 → 1 < 2
So, set 1->next = mergeTwoLists(3, 2)
Return 1.

Call 2:
mergeTwoLists(3, 2)
Compare 3 and 2 → 3 > 2
So, set 2->next = mergeTwoLists(3, 4)
Return 2.


Call 3:
mergeTwoLists(3, 4)
Compare 3 and 4 → 3 < 4
So, set 3->next = mergeTwoLists(5, 4)
Return 3.


Call 4:
mergeTwoLists(5, 4)
Compare 5 and 4 → 5 > 4
So, set 4->next = mergeTwoLists(5, 6)
Return 4.


Call 5:
mergeTwoLists(5, 6)
Compare 5 and 6 → 5 < 6
So, set 5->next = mergeTwoLists(NULL, 6)
Return 5.


Call 6:
mergeTwoLists(NULL, 6)
First condition → since first list is NULL, return 6.
 


Now unwind recursion:

From Call 6 → returns 6
So 5->next = 6
Return 5.

From Call 5 → returns 5
So 4->next = 5
Return 4.

From Call 4 → returns 4
So 3->next = 4
Return 3.

From Call 3 → returns 3
So 2->next = 3
Return 2.

From Call 2 → returns 2
So 1->next = 2
Return 1.


Note: At each recursive step, we pick the smaller node and let recursion handle the rest. Finally, the function connects all nodes in sorted order as the stack unwinds.



Sorting LinkedList(merge sort):
===============================



//merged two sorted List
Node* mergeTwoLists(Node* n1Head, Node* n2Head) {
    // Base cases
    if (n1Head == NULL) return n2Head;
    if (n2Head == NULL) return n1Head;

    // Recursive step
    if (n1Head->data < n2Head->data) {
        n1Head->next = mergeTwoLists(n1Head->next, n2Head);
        return n1Head;
    } else {
        n2Head->next = mergeTwoLists(n1Head, n2Head->next);
        return n2Head;
    }
}

// --- Split into two halves ---
Node* findMiddle(Node* head) {
    if (head == NULL || head->next == NULL) {
        return head;
    }

    Node* slow = head;
    Node* fast = head->next;  // notice: start fast one step ahead

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;  // node just before the mid
}


// --- Merge Sort for Linked List ---
Node* mergeSort(Node* head) {
    if (head == NULL || head->next == NULL) return head; // base case

    Node* mid = findMiddle(head);
    Node* second= mid->next;
    mid->next = NULL; // break the list

    Node* left = mergeSort(head);
    Node* right = mergeSort(second);

    return mergeTwoLists(left, right);
}




int main(){


    LinkedList l1;
    l1.insertAtBegining(50);
    l1.insertAtBegining(40);
    l1.insertAtBegining(30);
    l1.insertAtBegining(20);
    l1.insertAtBegining(10);
    l1.insertAtBegining(110);
    l1.insertAtBegining(22);

    l1.display();

    cout<<endl;

    l1.head= mergeSort(l1.head);

    cout<<"After sorting: \n";
    l1.display();
 
    return 0;
}



















