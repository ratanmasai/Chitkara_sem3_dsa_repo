Q1. The Parade Problem - Finding the Nth-to-Last Node

Imagine you are trying to find a specific person in a parade (the linked list). The people are numbered from the beginning, but you want to find the person who is N steps away from the END of the parade.

You cannot walk to the end and then count backward in a single trip.

Complete the function findNLast(head, n): Return the nth node from end of the list. If n is greater than size of the list, return the last node of list (return NULL if list is empty).


Input Format:

The first line will contains an integer i.e. number of test cases

Each test case contains three lines:

--First line denotes the number of nodes in list.
--Second line contains the node values.
--Third line contains an integer, denoting n.


Output Format:

--For each test case, print the Nth element from end in separate line.


Constraints:

1 <= no. of testcases <= 10
0 <= no. of nodes <= 10^5
0 <= node data <= 10^6
1 <= n <= 10^5

Sample Input
2  // testcases
5            // no. of nodes (TC-1)
1 2 3 4 5    // nodes's data
2            // n
6            // no. of nodes (TC-2)
1 2 3 4 5 6  // nodes's data
8            // n

Sample Output

4
6

Explanation:

In first list, the 2nd last element is 4.
In second list, the last element is 6.


Solution approach:
-------------------

Goal:

Find the n-th node from the end of a linked list.

Example:
List = 10 → 20 → 30 → 40 → 50
If n = 2, answer = 40


Step 1 — Count how many nodes are in the list

--We first walk from start to end and count:

size = number of nodes

Example: size = 5

Step 2 — If n is bigger than size → return LAST node

Example:
size = 5, n = 10
10 is bigger than 5 → return the last node (50).


Step 3 — Find how far we must move from the head

--If we want the n-th node from the END:

steps_from_head = size - n


Example: size = 5, n = 2
steps = 5 - 2 = 3

So we move 3 steps from head:

10 → 20 → 30 → 40

That’s our answer.


Step 4 — Move steps_from_head times and return that node

Done!

code:

Node* findNLast(Node* head, int n) {

    if (head == NULL) return NULL;   // empty list

    // Step 1: count nodes
    int size = 0;
    Node* temp = head;
    while (temp != NULL) {
        size++;
        temp = temp->next;
    }

    // Step 2: if n > size → return last node
    if (n > size) {
        temp = head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        return temp; // last node
    }

    // Step 3: calculate steps from head
    int steps = size - n;

    // Step 4: move steps times
    temp = head;
    while (steps--) {
        temp = temp->next;
    }

    return temp;
}






Q2. Runner Pointers

Imagine a train (the linked list) with a single engine (the head node) and many passenger cars (the remaining nodes).

Your goal is to find the exact middle car of the train while walking from the engine to the end only once.

To do this in a single trip, you employ a strategy with two people (pointers):

The Snail (Slow Pointer): This person walks at a normal speed, moving one car at a time.

The Runner (Fast Pointer): This person is very fast, moving two cars at a time.

The Rule: Both the Snail and the Runner start at the Engine. The Snail stops when the Runner reaches the very end of the train. Because the Runner was going twice as fast, the Snail must now be standing at the exact middle car!

Complete the findMiddle(head) function: Return the middle node if number of nodes in the linked list is odd, otherwise there will be two middle nodes and return the second middle node (return NULL if list is empty).

Input Format:

The first line will contains an integer i.e. number of test cases

Each test case contains two line. First line denotes the number of nodes in list and second line contains the node values.

Output Format:

For each test case, print the middle element of the list in separate line.

Constraints:

1 <= no. of testcases <= 10
0 <= no. of nodes <= 10^5
0 <= node data <= 10^6

Sample Input

2  // testcases
5            // no. of nodes (TC-1)
1 2 3 4 5    // nodes's data 
6            // no. of nodes (TC-2)
1 2 3 4 5 6  // nodes's data 

Sample Output

3
4

Explanation:

In first list, middle element is 3.
In second list, second middle element is 4.


Solution Approach:
------------------

Imagine a train where:

--Engine = head node

--Each passenger car = node

--You want to find the middle car in one single walk.

To do this, you use two people:

1. Snail (Slow Pointer)

--Moves 1 step at a time

2. Runner (Fast Pointer)

--Moves 2 steps at a time

Both start from the engine (head)

--When the fast pointer reaches the end of the train, the slow pointer will be at the middle.


Output Rule (Very Important)

If the list has odd number of nodes → return the middle node
Example: 1 2 3 4 5 → middle = 3

If the list has even number of nodes → there are two middle nodes
Example: 1 2 3 4 5 6

Two middles = 3 and 4
The question says: return the second middle → 4

If the list is empty → return NULL

Node* findMiddle(Node* head)






code:


#include <iostream>
using namespace std;

class Node {

private:
    int data;
    Node* next;

public:

    Node(int d) {
        data = d;
        next = NULL;
    }

};

Node* findMiddle(Node* head) {
    if (head == NULL) return NULL;  // empty list

    Node* slow = head;
    Node* fast = head;

    // Move fast by 2 and slow by 1
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
    }

    return slow;  // slow now points to middle node
}

int main() {
    int t;
    cin >> t;

    while (t--) {
        int n;
        cin >> n;

        Node* head = NULL;
        Node* tail = NULL;

        // build the linked list
        for (int i = 0; i < n; i++) {
            int x;
            cin >> x;
            Node* temp = new Node(x);

            if (head == NULL) {
                head = temp;
                tail = temp;
            } else {
                tail->next = temp;
                tail = temp;
            }
        }

        Node* mid = findMiddle(head);

        if (mid != NULL)
            cout << mid->data << endl;
        else
            cout << "NULL" << endl;
    }
}





Q3. Prize Manager

Imagine you have a chain (a linked list) of individual quiz scores (nodes) from your students. You are giving out a special prize, but only for scores that are less than or equal to a specific limit, X.

Your task is to go through this list of scores and throw out (delete) any score that is too high (greater than X). You only keep the passing scores that qualify for the prize.

Complete the function deleteGreater() in the editor, which will take head of the linked list as parameter, and it returns the head of a new list, in which no element (node) should have value greater than X.

Input Format

The first line contains an integer N, the size of the list.
The second line contains an integer X.
Each of the next N lines contains an integer list[i] where 0 ≤ i < N.

Output Format

Print the node values of the resultant list separated with space.

Constraints

0 ≤ N ≤ 10^5
1 ≤ X, list[i] ≤ 1000

Sample Input

6  // N
3  // X
2  // Elements of list
4
3
6
5
1

Sample Output

2 3 1

Explanation:

Nodes with the value 4, 6, 5 are deleted from the list, as they are greater than 3.



Solution approach:


We must delete nodes greater than X — this may include:

--nodes in the middle

--nodes at the end

--nodes at the beginning (head)

So we handle all cases.



Step 1: Clean the head

If head itself has a value > X:

--Move head forward until head->data ≤ X

--If all nodes are deleted → head becomes NULL

Step 2: Traverse the list and delete nodes

Use pointer curr:

curr = head

For each node:

--If curr->next->data is greater than X, delete curr->next

--Otherwise, move curr forward


Node* deleteGreater(Node* head, int X)


code:



#include <iostream>
using namespace std;

class Node {

private:
    int data;
    Node* next;

public:
    Node(int d) {
        data = d;
        next = NULL;
    }
};

Node* deleteGreater(Node* head, int X) {
    // Step 1: Remove nodes from the beginning if they are > X
    while (head != NULL && head->data > X) {
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    // If list becomes empty
    if (head == NULL) return NULL;

    // Step 2: Remove nodes from the rest of the list
    Node* curr = head;
    while (curr != NULL && curr->next != NULL) {
        if (curr->next->data > X) {
            Node* temp = curr->next;
            curr->next = curr->next->next;
            delete temp;
        } else {
            curr = curr->next;
        }
    }

    return head;
}

int main() {
    int N, X;
    cin >> N;
    cin >> X;

    Node* head = NULL;
    Node* tail = NULL;

    // Build the linked list
    for (int i = 0; i < N; i++) {
        int val;
        cin >> val;

        Node* temp = new Node(val);

        if (head == NULL) {
            head = temp;
            tail = temp;
        } else {
            tail->next = temp;
            tail = temp;
        }
    }

    // Process deletion
    head = deleteGreater(head, X);

    // Print result
    Node* curr = head;
    while (curr != NULL) {
        cout << curr->data << " ";
        curr = curr->next;
    }

    return 0;
}




Q4. The Ticket Queue Problem

Imagine a Ticket Queue (the array) where people (elements) line up to buy concert tickets. Some people are lining up alone, while others are lining up with identical-looking duplicates (friends wearing the same costume).

The Goal: You are tasked to find the K-th person in the line who is truly UNIQUE (a "distinct element")—meaning, no one else with the same identity is present anywhere in the entire line.

If there are fewer than K distinct person, then return 0 as the answer.

Note: The elements are considered in the same order in which they appear in the array from left to right.

Example: arr[] = {6, 11, 4, 11, 9, 4}, K = 2

The only distinct elements in the array are 6 and 9.

6 appears first so it the 1st distinct element,and 9 appears second so it the 2st distinct element in the array. Hence, for K=2 the answer is 9.

Input Format:

First line of input contains T = number of test cases.
Each test case contains three lines:
  First Line will contain an integer N, denoting the size of the array.
  Second line contains N integers separated by space, denoting the array elements.
  Third line contains an integer representing K.

Constraints:

1 <= T <= 10
1 <= N <= 10^5
1 <= arr[i] <= 10^5
1 <= K <= N

Output Format:

Print the Kth distinct element present in the array.

Sample Input 1
3  // Test Cases
6             // N (testcase 1)
6 11 4 11 9 4 // arr[]
2             // K  
5             // N (testcase 2)
7 6 7 3 6     // arr[]
1             // K
6             // N (testcase 3)
8 5 3 5 5 5   // arr[]
4             // K

Sample Output
9
3
0

Explanation

Testcase 1:

9 is the 2nd distinct element present in the array from left to right

Testcase 2: 

3 is the first distinct element present in the array from left to right

Testcase 3:

Only 2 distinct elements are present in the array, i.e., 8 and 3
Since there are less than 4 distinct elements, therefore the answer is 0


Solution Approach:
------------------


You must find the K-th distinct person, i.e., a person who appears exactly once in the whole queue.

If fewer than K distinct people exist → return 0.


Example:

arr[] = {6, 11, 4, 11, 9, 4}
K = 2

First, count how many times each number appears:

Element 	Frequency

6		1
11		2
4		2
9		1


Now extract the distinct elements (frequency = 1) in the order they appear:

6 → 1st distinct

9 → 2nd distinct

So the 2nd distinct element = 9


Approach:

Step 1: Count frequencies

--Use a hashmap (unordered_map):

frequency[arr[i]]++


Step 2: Traverse array again

--Now check elements in the same left-to-right order:

--If frequency[arr[i]] == 1:

--This is a distinct element

--Increase count

--When count == K → return arr[i]


Step 3: If distinct elements < K

Return 0



int findKthDistinct(vector<int> &arr, int K)


arr[] = {6, 11, 4, 11, 9, 4}
K = 2

Answer: 9

code:




#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

int findKthDistinct(vector<int> &arr, int K) {
    unordered_map<int, int> freq;

    // Step 1: Count frequencies
    for (int x : arr) {
        freq[x]++;
    }

    // Step 2: Find K-th distinct element
    int count = 0;
    for (int x : arr) {
        if (freq[x] == 1) {  // distinct element
            count++;
            if (count == K) {
                return x;
            }
        }
    }

    // Step 3: less than K distinct elements
    return 0;
}

int main() {
    int T;
    cin >> T;

    while (T--) {
        int N;
        cin >> N;

        vector<int> arr(N);
        for (int i = 0; i < N; i++) {
            cin >> arr[i];
        }

        int K;
        cin >> K;

        cout << findKthDistinct(arr, K) << endl;
    }

    return 0;
}




Q5. Count the leaders in a company

An IT company is developing some complex software, and to successfully deliver it on time, they want to constitute a new team of leaders. Given an array, that contains the employee IDs in some particular order. Your task is to find, the total number of leaders in that IT company. An employee is called a leader if its ID is greater than all the employee IDs to its right side, in the given array. Note that the employee at the rightmost position in the array is always a leader.

For example, in the array {12, 27, 14, 11, 25, 6, 7}, there are 3 leaders with the following employee IDs: 27, 25 and 7.

Complete the function countTheLeaders() that accepts the array as input and returns the count of leaders in it.

Input Format

First Line will contain an integer N, denoting the number of employees in the company.
Second line contains N integers separated by space, denoting the employee IDs.

Output Format

Print the number of leaders in that IT company.

Constraints

1 <= N <= 10^5
1 <= EmpIDs[i] <= 10^9
All the employee Ids will be unique

Sample Input

7
12 27 14 11 25 6 7

Sample Output

3



Solution Approach:
------------------

--You are given an array of employee IDs, and you must count how many of them are leaders.

What is a Leader?

An employee ID is called a leader if:

--It is greater than all IDs to its right in the array.

--The rightmost employee is always a leader (because no one is to its right).


Example:

12 27 14 11 25 6 7


Check from right to left:

Start at 7 → leader

Next: 6 → not bigger than 7 → not leader

Next: 25 → bigger than all on the right (6, 7) → leader

Next: 11 → not bigger than 25 → not leader

Next: 14 → not bigger than 25 → not leader

Next: 27 → bigger than all on the right → leader

Last: 12 → not bigger than 27 → not leader


Leaders are:

27, 25, 7


Total =3


Approach:


Steps:

1. Start from the rightmost element

→ This is always a leader
→ Set: maxRight = last element

2. Move leftwards through the array:

If arr[i] > maxRight

→ This is a leader
→ Update maxRight = arr[i]

Else, not a leader

Count how many leaders you find.


int countTheLeaders(vector<int> &arr)




code:


#include <iostream>
#include <vector>
using namespace std;

int countTheLeaders(vector<int> &arr) {
    int n = arr.size();
    int count = 0;

    int maxRight = arr[n - 1];
    count = 1;  // rightmost is always a leader

    // Traverse from second last to start
    for (int i = n - 2; i >= 0; i--) {
        if (arr[i] > maxRight) {
            count++;
            maxRight = arr[i];
        }
    }

    return count;
}

int main() {
    int N;
    cin >> N;

    vector<int> arr(N);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    cout << countTheLeaders(arr);

    return 0;
}





Q6. Riya and the Reversed Message

Riya received a strange message from her friend Aman:

!dlroW olleH

She remembers Aman once said:

"If you ever encounter a reversed message, just stack it up and you'll see the real message!"

Now, Riya needs your help to decode the message.

Your task is to complete the reverseString() to help Riya reverse the message and reveal what Aman truly said.

Sample Input:

!dlroW olleH

Sample Output:

Hello World!



Solution Approach:
------------------

Reverse the entire string

--Read the entire string (including spaces)

--Reverse the characters from end to start

--Print the reversed string


You can reverse it using:

1. A loop

2. stack<char>

3. reverse() function

4. Manual pointer swapping

5. Using recurrsion

string reverseString(string s) //using manual pointer swapping


code:


string reverseString(string s) {

    int left = 0;
    int right = s.length() - 1;

    while (left < right) {
        swap(s[left], s[right]);   // using swap() function
        left++;
        right--;
    }

    return s;
}




Using recurssion:
-----------------


void reverseHelper(string &s, int left, int right) {
    // Base Case
    if (left >= right)
        return;

    // Swap characters
    swap(s[left], s[right]);

    // Recursive call
    reverseHelper(s, left + 1, right - 1);
}

string reverseString(string s) {
    reverseHelper(s, 0, s.length() - 1);
    return s;
}





Q7. Heena counting characters


Heena loves to count English alphabets from any kind of string, so her mentor has given her a similar kind of task, that is as follows:

Given a string that contains only lowercase English alphabets, she has to print all the distinct alphabets in the sorted order along with their frequencies. For example if the string is “helloworld”, then she should print d1 e1 h1 l3 o2 r1 w1 .

Complete the given function countFrequency(), which takes a string as input and prints the frequency of each character as per the above 
statement.

Input Format

First line contains a string with lowercase characters.

Constraints

'a' <= str[i] <= 'z'
1 <= length of str <= 100000

Output Format

Print all the distinct characters along with their frequency followed by a space. And the characters must be printed in the sorted order.

Sample Input

codequotient

Sample Output

c1 d1 e2 i1 n1 o2 q1 t2 u1



Solution Approach:
------------------


You are given a string containing only lowercase English letters.

Your job:

--Count how many times each character occurs.

--Print distinct characters in sorted order, each followed by its frequency.

Format:

character + frequency + space


Example:

helloworld → d1 e1 h1 l3 o2 r1 w1


Approach:

Step 1: Create a frequency array of size 26

Because all characters are lowercase 'a' to 'z'.

Index = character - 'a'

--arrays use integer indexes, and characters are stored as ASCII values.

For lower case letters:

Charecter	ASCII

'a'		97
'b'		98
..
'z'		122


If you want 'a' to map to 0, 'b' to 1, … 'z' to 25:

Just subtract 'a'

Example:

Let’s say,
ch = 'c'


Then

index = ch - 'a'
index = 'c' - 'a'
index = 99 - 97
index = 2



Step 2: Traverse the string

freq[c - 'a']++


Step 3: Print characters in sorted order

Loop from i = 0 to 25:

If freq[i] > 0, print:

(char)(i + 'a') << freq[i] << " "




void countFrequency(string s)




code:


#include <iostream>
#include <string>
using namespace std;

void countFrequency(string s) {
    int freq[26] = {0};

    // Count frequencies
    for (char c : s) {
        freq[c - 'a']++;
    }

    // Print in sorted order
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {
            cout << char(i + 'a') << freq[i] << " ";
        }
    }
}

int main() {
    string s;
    cin >> s;

    countFrequency(s);

    return 0;
}




Q8. CaesarCipher


You need to write a method by the name CaesarCipher that performs a Caesar cipher (also known as a rotation cipher). This is a basic method of encoding strings by shifting each letter in the message forward or backward by a given number of positions in the alphabet. The Method should accept a string - message and an encoding "key" (number of places to shift each character) and should return the shifted message.

For example, if the shift amount(key) is 3, then the letter A becomes D, and B becomes E, and so on. Letters near the end of the alphabet wrap around; for a shift of 3, X becomes A, and Y becomes B, and Z becomes C. 

NOTE - The Method Should Only shift alphabetic characters.

Sample Input 1:

Attack zerg at Down
3

Sample Output 1:

DWWDFN CHUJ DW GDZQ

Sample Input 1:

DWWDFN CHUJ DW GDZQ -3

Sample Output 2:

ATTACK ZERG AT DOWN



Solution Approach:
------------------

You are asked to write a method CaesarCipher(message, key) that encodes or decodes a message by shifting each alphabetic character.



It shifts each letter in the alphabet:

--Forward if key is positive

--Backward if key is negative

For example, with a shift of +3:


A → D  
B → E  
C → F


Letters at the end of the alphabet wrap around:

X → A  
Y → B  
Z → C



And with a shift of -3 (decoding):

D → A  
W → T



Important Rules

1. The method should only shift alphabetic characters

Letters → shifted

Spaces → remain the same

Symbols (!, ?, etc.) → remain the same

--Output in sample is UPPERCASE, so we print uppercase.
--Shifting must wrap around using modulo 26.


Example 1 (Encoding)

Input:

Attack zerg at Down
3


Shift every letter by +3 positions:

A → D
T → W
T → W
A → D
C → F
K → N


Space remains a space.

zerg shifts to CHUJ

Final output:

DWWDFN CHUJ DW GDZQ



Example 2 (Decoding)

Input:

DWWDFN CHUJ DW GDZQ
-3


We shift backward 3 positions:

D → A
W → T
Q → N
Z → W


Final output:

ATTACK ZERG AT DOWN



Formula to compute new letter:

newIndex = (oldIndex + key + 26) % 26





string CaesarCipher(string s, int key) 







code:


#include <iostream>
#include <string>
using namespace std;

string CaesarCipher(string s, int key) {
    string result = "";
    
    // Normalize key to avoid issues with large numbers
    key = key % 26;



    for (char c : s) {
        if (isalpha(c)) {
            char base = 'A';  // convert everything to uppercase
            char upperC = toupper(c);

            int oldIndex = upperC - base;
            int newIndex = (oldIndex + key + 26) % 26;  // +26 avoids negative modulo
            char newChar = base + newIndex;

            result += newChar;
        } 
        else {
            result += c; // keep spaces or other characters
        }
    }

    return result;
}

int main() {
    string message;
    int key;

    getline(cin, message);
    cin >> key;

    cout << CaesarCipher(message, key);

    return 0;
}














Q9. Fair Distribution By Santa


On the eve of Christmas, Santa distributed candies among N children. But soon after, Santa realized that he had not done the fair distribution. According to him, if the difference of candies between any two children is more than K, then the distribution is not fair. Therefore, he decided to take some candies back from the children.

Now, given an array, denoting the initial number of candies given to each child, your task is to determine the minimum number of total candies that Santa has to take back, in order to achieve the fair distribution.

For example, if N = 5, K = 3 and candies[N] = {5, 3, 6, 2, 8}, then we can clearly observe that - the difference of candies between (second and fifth) child, (third and fourth) child, and (fourth and fifth) child is greater than 3. Therefore, some candies need to be removed. So, if we remove 1 candy from the third child and 3 candies from the fifth child, then the distribution will become fair, i.e. {5, 3, 5, 2, 5}. So, in total, Santa has to take back a minimum of 4 candies from those children.

Input Format:

First Line will contain an integer N, denoting the number of children.
Second line contains N space separated integers, denoting the initial number of candies given to each child.
Third line contains an integer K.

Constraints:

1 <= N <= 10^5
0 <= candies[i] <= 10^9
0 <= K <= 10^5

Output Format:

Print the minimum number of total candies that Santa has to take back, in order to achieve the fair distribution.

Sample Input 1
5          // N
5 3 6 2 8  // candies[]
3          // K

Sample Output 1
4

Sample Input 2
4        // N
3 3 3 3  // candies[]
0        // K

Sample Output 2
0

Explanation
As K = 0 and all the children are having same number of candies,
therefore, the distribution is already fair. So, no candy is taken back.




Solution Approach:
-----------------

Santa gave candies to N children, but now he wants the distribution to be fair.

Fair Distribution Rule

A distribution is fair if:

--The difference in candies between any two children is not more than K.

max candies – min candies ≤ K


If the difference is larger, Santa must take back candies from children (he never adds candies).

You must compute the minimum total candies Santa should take back.


Important Observation:

--Santa can only remove candies, not add.

So the best he can do is:

Reduce all candy counts to some upper limit
such that the difference between the highest and lowest becomes ≤ K.


Key Idea:

To make the distribution fair:

Every child’s candies must be ≤ (minimum_candies + K)


Let minCandy = minimum number of candies initially given.

If the rule must hold:

max_allowed = minCandy + K


Any child having candies more than max_allowed must be reduced.


Example 1


N = 5,  K = 3
candies = {5, 3, 6, 2, 8}


Step 1: Find minimum candy

minCandy = 2


Step 2: max allowed

maxAllowed = minCandy + K = 2 + 3 = 5


Step 3: Reduce all elements > 5


| Child | Initial | Allowed | Removed |
| ----- | ------- | ------- | ------- |
| 1     | 5       | ≤ 5     | 0       |
| 2     | 3       | ≤ 5     | 0       |
| 3     | 6       | 5       | 1       |
| 4     | 2       | 2       | 0       |
| 5     | 8       | 5       | 3       |


Total removed = 1 + 3 = 4


Approach (Step-by-step)

Step 1: Find minCandy in the array
Step 2: maxAllowed = minCandy + K
Step 3: For every candy[i]

If candy[i] > maxAllowed:


Step 4: Print remove

This gives the minimum candies Santa must take back.


code:







#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N;
    cin >> N;

    vector<int> candies(N);
    for (int i = 0; i < N; i++) {
        cin >> candies[i];
    }

    int K;
    cin >> K;

    // Step 1: Find minimum candy manually
    int minCandy = candies[0];
    for (int i = 1; i < N; i++) {
        if (candies[i] < minCandy) {
            minCandy = candies[i];
        }
    }

    // Step 2: Calculate maximum allowed candies
    int maxAllowed = minCandy + K;

    // Step 3: Calculate how many candies Santa will take back
    int removed = 0;
    for (int i = 0; i < N; i++) {
        if (candies[i] > maxAllowed) {
            removed += (candies[i] - maxAllowed);
        }
    }

    // Step 4: Print the result
    cout << removed;

    return 0;
}
