Google Docs Notes: https://docs.google.com/document/d/1v6gjLzfdj6mVfIcaElyNTFigKlkIk_1efUiiqwGm9rU/edit?tab=t.co1forjufin8


Stack Data structure:
=====================

--A Stack is a linear data structure that follows LIFO (Last In First Out) principle.

--The element inserted last is removed first.


Use cases:
-----------

1. We can use stack to implement undo feature.

2. To build navigation (forward/backword)

3. Build compilers (ex:-syntax checking)

4. Evaluate mathmatic expression (ex:- 1+2*3)

5. Function Call Stack (used in recursion & program execution)


Example:
---------

--Stacks of plates (we can only view or remove the top plate).
--If we want to get bottom plate then we need to remove all plates one by one.(LIFO)


Implementation:
--------------

Internally, we can implement Stack in C++ using:

1. Arrays/vector

2. Linked List

It’s basically a wrapper around arrays/LL with special access rules.

3. STL stack (wrapper around deque/vector/list)



Basic Stack Operations:
----------------------- 

1. push(item) → add an item on top:  O(1)

2. pop() → remove the top item: O(1)

3. peek()/top() → return the top item without removing: O(1)

4. isEmpty() → check if stack is empty: O(1)

5. display() → Show all the elements: O(n) : optional


Code: using array:
-----------------


#include <iostream>
#define MAX 10 // maximum size of stack
using namespace std;

class MyStack{

private:

int items[MAX]; // array to store stack elements
int count; // number of elements in stack


public:
    
    // Constructor
    MyStack(){
        count=0;
    }


    //Push element on stack
    void push(int item){

        if(count == MAX){//stack full
            cout<<"Stack Overflow!" <<endl;
            return;
        }  

        items[count++] = item;
    }

    //Pop element from stack
    int pop(){

        if(count == 0){ //Stack empty
            cout<<"Stack Underflow! "<<endl;
            return -1; //return some invalid value.
        }

        return items[--count];


    }

    // Peek top element
    int peek() {
        if (count == 0) {
            cout << "Stack is Empty!" << endl;
            return -1;
        }
        return items[count - 1];
    }

    // Check if stack is empty
    bool isEmpty() {
        return count == 0;
    }

    void display(){

        if(count == 0){
            cout<<"Stack is empty \n";
            return;
        }

        cout<<"Stack elements (top to down)" <<endl;
        for(int i=count-1;i>=0;i--){
            cout<<items[i] <<" ";
        }

        cout<<endl;


    }


};

int main(){

    MyStack s;

    s.push(10);
    s.push(20);
    s.push(30);
    s.push(40);
    s.push(50);
    
    s.display();

    
    cout << "Peek top: " << s.peek() << endl;

    cout << "Popped: " << s.pop() << endl;
    cout << "Popped: " << s.pop() << endl;

    s.display();

    cout << "Is stack empty? " << (s.isEmpty() ? "Yes" : "No") << endl;


    return 0;
}



Another way using top pointer:
-----------------------------



#include <iostream>
#define MAX 10
using namespace std;

class StackArray{

private:

    int items[MAX];
    int top;

public:

    StackArray(){
       top = -1;
    }
    

    bool isEmpty(){
        return top == -1;
    }

    bool isFull(){
        return top == MAX-1;
    }


    void push(int item){

        if(isFull()){
            cout<<"Stack Overflow ! \n";
            return;
        }


        items[++top] = item;

    }

    int pop(){

        if(isEmpty()){
            cout<<"Stack Underflow (empty) ! \n";
            return -1;
        }

        return items[top--];


    }

    int peek(){
         if(isEmpty()){
            cout<<"Stack Underflow (empty) ! \n";
            return -1;
        }

        return items[top];

    }

    int getSize(){
	return top+1;        
    }

   

    void display(){

        if(isEmpty()){
            cout<<"Stack is empty \n";
            return;
        }

        for(int i=top; i>=0;i--){
            cout<<items[i] <<" ";
        }

        cout<<endl;


    }




};





int main() {
    

    StackArray s1;

    s1.push(50);
    s1.push(40);
    s1.push(30);
    s1.push(20);
    s1.push(10);

    s1.display();


    cout<<"Pop the item from top: "<<s1.pop() <<endl;

    s1.display();

    cout<<"\n See the TOP item: "<<s1.peek() <<endl;

    s1.display();


    return 0;
}








Using vector:
------------

#include <iostream>
#include <vector>
using namespace std;

class MyStack {
private:
    vector<int> items;   // vector to store stack elements

public:

    // Push element onto stack
    void push(int item) {
        items.push_back(item);  // push at the end
        cout << item << " pushed into stack." << endl;
    }

    // Pop element from stack
    int pop() {
        if (items.empty()) {
            cout << "Stack Underflow!" << endl;
            return -1;  // return some invalid value
        }
        int topItem = items.back();
        items.pop_back();   // remove last element
        cout << topItem << " popped from stack." << endl;
        return topItem;
    }

    // Peek top element
    int peek() {
        if (items.empty()) {
            cout << "Stack is Empty!" << endl;
            return -1;
        }
        return items.back();
    }

    // Check if stack is empty
    bool isEmpty() {
        return items.empty();
    }

    // Display stack elements
    void display() {
        if (items.empty()) {
            cout << "Stack is empty" << endl;
            return;
        }
        cout << "Stack elements (top to bottom): ";
        for (int i = items.size() - 1; i >= 0; i--) {
            cout << items[i] << " ";
        }
        cout << endl;
    }
};





Note: To prevent the memory leak we should add the following destructure iniside the above MyStack class:

~MyStack() {
    while (!isEmpty()) {
        pop();
    }
}


Note: This is not needed for vector-based implementation because std::vector automatically frees memory.
It is needed for Linked List implementation or array implementation to prevent memory leaks.


Using Linked List:
==================


Why Linked List instead of Array/Vector?
-----------------------------------------

1. Dynamic Size: 

--Array/Vector-based stack has a fixed size (or needs resizing).
--Linked List grows/shrinks dynamically → no overflow (except memory full case).

2. Efficient Memory Usage: 

--Array may waste memory (if pre-allocated but unused).
--LL uses exactly what is required.

3. Constant-Time Operations:

--push() and pop() always O(1) (no shifting, no resizing).
--In vector, resizing can take O(n) in worst case.

4. Flexibility:

--Useful when we don’t know the maximum number of elements in advance.


Downside: LL needs extra memory for next pointer, and cache locality is worse than arrays.



--Use array-based stack if maximum size is known and performance matters.
--Use linked list stack if size is unknown or can grow very large.

code:
-----


class Node{

public:

    int data;
    Node* next;

    Node(int data){
        this->data= data;
        this->next = NULL;
    }

};

class MyStack{

private: 

    Node* top; //pointer to top node
    int size;

public: 

    //constructor
    MyStack(){
        top= NULL;
	size=0;
    }


    //Push element on stack
    void push(int value){
        Node* newNode = new Node(value);

        newNode->next = top;//new node points to the old top
        top = newNode; //update top
        cout<<value <<" pushed into the stack" <<endl;
        size++;
    }



    //Pop element from stack
    int pop(){
        if(top == NULL){
            cout<<"Stack is empty! " <<endl;
            return -1;
        }

        int poppedValue = top->data;
        Node* temp = top;
        top = top->next; //move the top down
        delete temp; // free memory
        size--; //decrease the count
        cout<<poppedValue <<" Popped from the stack" <<endl;
        return poppedValue;
    }


    //peek top element
    int peek(){
        if(top == NULL){
            cout<<"Stack is empty \n";
            return -1;
        }

        return top->data;

    }

    bool isEmpty(){
        return top == NULL;
    }

    int getSize(){
        return size;
    }

    void display(){

        if(isEmpty()){
            cout<<"Stack is empty \n";
            return;
        }

        cout<<"Stack elements (top to bottom) \n";
        Node* current= top;

        while(current != NULL){
            cout<<current -> data <<" ";
            current = current -> next;
        }

        cout<<endl;


    }

};




Using STL(C++):
=================

#include <iostream>
#include <stack>
using namespace std;


int main() {
   // Declare stack of integers
   stack<int> s;


   // Push elements
   s.push(10);
   s.push(20);
   s.push(30);


   cout << "Top element: " << s.top() << endl; // should print 30


   // Pop element
   s.pop();
   cout << "Top element after pop: " << s.top() << endl; // should print 20


   // Size of stack
   cout << "Stack size: " << s.size() << endl;


   // Check if empty
   if(s.empty())
       cout << "Stack is empty" << endl;
   else
       cout << "Stack is not empty" << endl;


   // Display all elements (by popping)
   cout << "Stack elements (top to bottom): ";
   while(!s.empty()) {
       cout << s.top() << " ";
       s.pop();
   }
   cout << endl;


   return 0;
}



Stack related Problems:
========================


1. Balanced expression:
------------------------


Q/- What is a Balanced Expression?

--A balanced expression is one where:

--Every opening bracket has a corresponding closing bracket.

--Brackets are properly nested (correct order).


Examples:

(1+2)

{[()()]}

<{(2+3)*[5]}>


Where the followings are not balanced:


(1+2 : (missing ))

(1+2] : (mismatched ])

((1+2) : (extra opening)

){1+2} : (wrong order)



Real-life analogy:
-------------------

Think of brackets as doors:

--When you open a door ((, {, <, [), you must close it in the reverse order.

--If you open multiple doors, you close the most recent one first (LIFO principle → use Stack).



How do we check balance?
------------------------

Algorithm:

1. Traverse expression character by character.

2. If you see an opening bracket, push it on the stack.

3. If you see a closing bracket:

--If the stack is empty →  unbalanced.

--Otherwise pop from the stack and check if it matches.

4. After traversing, if the stack is empty →  balanced.



Example1: Handle only ( and )
------------------------------


#include <iostream>
#include <stack>
using namespace std;


bool isBalanced(string str){

    stack<char> s;

    for(char ch: str){

        if(ch == '(')
            s.push(ch);

        else if(ch == ')'){
            if(s.empty())
                return false;
            
             if(st.top() == '(')
                st.pop();
        }
    }

        return s.empty();

};





int main(){


    cout<<(isBalanced("(1+2)") ? "Balanaced" : "Not Balanaced");
    cout<<endl;
    cout<<(isBalanced("((1+2)") ? "Balanaced" : "Not Balanaced");
    cout<<endl;
    

    return 0;
}


Example2: Support All Brackets () {} [] <>
--------------------------------------------

#include <iostream>
#include <stack>
using namespace std;

 bool isBalanced(string str) {
        stack<char> s;

        for (char ch : str) {
            if (ch == '(' || ch == '{' || ch == '[' || ch == '<') {
                s.push(ch);
            }
            else if (ch == ')' || ch == '}' || ch == ']' || ch == '>') {
                if (s.empty()) 
			return false;

                char top = s.top(); //getting the top 

                if ((ch == ')' && top != '(') ||
                    (ch == '}' && top != '{') ||
                    (ch == ']' && top != '[') ||
                    (ch == '>' && top != '<')) {
                    return false;
                }

		s.pop(); // removing the top and making top down
            }
        }

        return s.empty();
    }




int main(){


    cout<<(isBalanced("{<(1+2)>}") ? "Balanaced" : "Not Balanaced");
    cout<<endl;
    cout<<(isBalanced("{(1+2]>}") ? "Balanaced" : "Not Balanaced");
    cout<<endl;
    
    return 0;
}


Time Complexity: O(n).

Space Complexity: O(n).


Refactoring the above code:
---------------------------

#include <iostream>
#include <stack>
using namespace std;

bool isLeftBracket(char ch) {
    return (ch == '(' || ch == '{' || ch == '[' || ch == '<');
}

bool isRightBracket(char ch) {
    return (ch == ')' || ch == '}' || ch == ']' || ch == '>');
}

bool bracketsMatch(char left, char right) {
    if (left == '(' && right == ')') return true;
    if (left == '{' && right == '}') return true;
    if (left == '[' && right == ']') return true;
    if (left == '<' && right == '>') return true;
    return false;
}

bool isBalanced(string str) {
    stack<char> s;

    for (char ch : str) {
        if (isLeftBracket(ch)) {
            s.push(ch);
        } 
        else if (isRightBracket(ch)) {
            if (s.empty()) 
		return false;

            char top = s.top();

            if (!bracketsMatch(top, ch)) {
                return false;
            }
	    s.pop();
        }
    }
    return s.empty();
}

int main() {
    string str1 = "{<(1+2)>}";
    string str2 = "{(1+2]>}";

    cout << (isBalanced(str1) ? "Balanced" : "Not Balanced ") << endl;
    cout << (isBalanced(str2) ? "Balanced " : "Not Balanced ") << endl;

    return 0;
}




Above program using unorderedMap:
=================================

#include <iostream>
#include <stack>
#include <unordered_map>
using namespace std;

bool isBalanced(string s) {
    stack<char> st;

    // closing → opening map
    unordered_map<char, char> brackets = {
        {')', '('},
        {'>', '<'},
        {'}', '{'},
        {']', '['}
    };

    for (char c : s) {
        // If it's 'c' is opening bracket, push
        if (c == '(' || c == '{' || c == '<' || c == '[') {
            st.push(c);
        }
        // If it's a closing bracket
        else if (brackets.find(c) != brackets.end()) { //if 'c' found in the map
            if (st.empty() || st.top() != brackets[c]) { //brackets[')'] = '('
                return false; // mismatch
            }
            st.pop();
        }
        
    }

    return st.empty(); // true only if all brackets matched
}

int main() {
    string str1 = "{<(1+2)>}";
    string str2 = "{(1+2]>}";
    string str3 = "a+(b*c)-{d/e}";  // test with letters/operators

    cout << (isBalanced(str1) ? "Balanced" : "Not Balanced") << endl;
    cout << (isBalanced(str2) ? "Balanced" : "Not Balanced") << endl;
    cout << (isBalanced(str3) ? "Balanced" : "Not Balanced") << endl;

    return 0;
}

DRY RUN:
--------

exp = [(a+b)]


Step 1: char = '['

It's an opening bracket.

Push onto stack.

Stack: [

Step 2: char = '('

It's an opening bracket.

Push onto stack.

Stack: [ (

Step 3: char = 'a'

Not a bracket.

Ignore.

Stack: [ (

Step 4: char = '+'

Not a bracket.

Ignore.

Stack: [ (

Step 5: char = 'b'

Not a bracket.

Ignore.

Stack: [ (

Step 6: char = ')'

It's a closing bracket.

Map says ')' should match '('.

Stack top = '('  matches.

Pop.

Stack: [

Step 7: char = ']'

It's a closing bracket.

Map says ']' should match '['.

Stack top = '['  matches.

Pop.

Stack: empty




Polish Notation:
================

--Polish Notation is a way of writing arithmetic expressions without the need for parentheses to define operator precedence.

--It was introduced by a Polish mathematician.

--Infix Notation (Normal form): The usual way humans write expressions is called Infix Notation, where the operator is written between operands.
Example:

(A + B) * C


Types of Polish Notation:
-------------------------


--Polish Notations are generally of 2 types: B + C *     // equivalent to (A + B) * C


1. Prefix Notation(Polish Notation): Operator comes before operands.
Example:

* + A B C     // equivalent to (A + B) * C

2. Postfix Notation(Reverse Polish notation): Operator comes after operands.
Example:

A

Note: Computers often use Postfix (RPN) internally because it is easier to evaluate using a stack, without needing parentheses or complex precedence rules.



Operator Precedence & Associativity:
------------------------------------

--When converting infix → postfix/prefix, precedence and associativity of operators matter.


Operator		Precedence		Associativity

^ (exponent)		Highest			Right to left

*, /, %			Higher			Left to Right

+, -			Lower			Left to Right

Parentheses () {} []	Highest for grouping



Rules:
------

--Highest precedence operators are handled first 
--For the same precedence associativity decides the order.



Infix → Postfix Conversion (Step-by-Step Rules):
------------------------------------------------

Rules:
------

1. Operands (A-Z, 0-9): Directly add to the result. isalnum(ch) <cctype>  result+=ch 

2. Left Parenthesis ‘(’: Push onto stack.

3. Right Parenthesis ‘)’:

--Keep popping operators from the stack and add them to result until you find a (.
--Remove ( from the stack (do not add it to result).

4. Operators (+, -, , /, ^): 

--while the stack is not empty and,
	--top has higher precedence, OR
	--top has same precedence and operator is left-to-right associative
		--pop from stack
--Then push the current operator

5. At the end: After scanning the whole expression, pop all remaining operators from the stack and add them to the result.



Simple analogy:
-----------------


Imagine you are in a canteen line:

--Operands (A, B, C, numbers) → these are students. Students directly go to the counter (output).

--Operators (+, -, , /, ^) → these are teachers. Teachers don’t directly go to the counter; they first go to the staff room (stack).

--Stack → the staff room where teachers sit according to their importance (precedence).

Rules of the staff room:

--Higher priority teachers (like ^) sit on top.

--If a new teacher comes and has lower or equal priority, the top teacher leaves the staff room first (goes to output), then the new one can sit.

--Parentheses work like special temporary rooms:

( → open a new temporary room.

) → empty that room until ( is found.


Rules with above analogy:
------------------------

1. Operands (A-Z, 0-9)
→ Directly go to output (students → counter).

2. '(' (opening bracket)
→ Push into stack (open temporary room).

3. ')' (closing bracket)
→ Pop from stack to output until you find (. Remove the ( (but don’t put it in output).

4. Operators (+, -, , /, ^)

--If stack is empty → push it.

--If stack top is another operator → compare precedence.

a. If new operator has lower or equal precedence → pop from stack to output, then push the new operator.
b. If new operator has higher precedence → push it directly.

5. After scanning the expression

→ Pop everything left in the stack and put into output.




Example1: A + B * C
--------------------


Step 1: Operand A → Postfix: A

Step 2: Operator + → Stack: +

Step 3: Operand B → Postfix: A B

Step 4: Operator * → Higher precedence than + → push → Stack: + *

Step 5: Operand C → Postfix: A B C

End: Pop stack → * +


Result Postfix : A B C * +


Example2: (A + B) * C
----------------------

Step 1: ( → push → Stack: (

Step 2: A → Postfix: A

Step 3: + → push → Stack: ( +

Step 4: B → Postfix: A B

Step 5: ) → pop until ( → Postfix: A B +

Step 6: * → push → Stack: *

Step 7: C → Postfix: A B + C

End: Pop stack → *


Result Postfix: A B + C *



Code:
------

#include <iostream>
#include <stack>
#include <cctype>  // for isalnum
using namespace std;

// Function to return precedence of operators
int precedence(char op) {
    if (op == '^') return 3;
    if (op == '*' || op == '/' || op == '%') return 2;
    if (op == '+' || op == '-') return 1;
    
    // for any other charecter except: above operators
    return -1;
}

// Function to convert Infix to Postfix
string infixToPostfix(string exp) {
    stack<char> st;
    string result = "";

    for (char ch : exp) {
        // 1. If operand, add to result
        if (isalnum(ch)) {
            result += ch;
        }
        // 2. If '(', push to stack
        else if (ch == '(') {
            st.push(ch);
        }
        // 3. If ')', pop until '('
        else if (ch == ')') {
            while (!st.empty() && st.top() != '(') {
                result += st.top();
                st.pop();
            }
            if (!st.empty()) 
		st.pop(); // pop '('
        }
        // 4. If operator
        else {
            while (!st.empty() && precedence(st.top()) >= precedence(ch)) {
                result += st.top();
                st.pop();
            }
            st.push(ch);
        }
    }

    // Pop remaining operators
    while (!st.empty()) {
        result += st.top();
        st.pop();
    }

    return result;
}

int main() {
    string exp = "(A+B)*C";
    cout << "Infix Expression: " << exp << endl;
    cout << "Postfix Expression: " << infixToPostfix(exp) << endl;
    return 0;
}



DRY RUN: (A+B)*C
--------

Expected Postfix: AB+C*

Step 1: Read (

( = opening bracket → push into stack.

Stack: (

Output: (empty)

Step 2: Read A

A = operand (student) → goes directly to output.

Stack: (

Output: A

Step 3: Read +

+ = operator (teacher).

Stack top is ( → so just push +.

Stack: ( +

Output: A

Step 4: Read B

B = operand → directly to output.

Stack: ( +

Output: AB

Step 5: Read )

Closing bracket → pop until you find (.

Pop + → goes to output.

Remove ( (don’t put it in output).

Stack: (empty)

Output: AB+

Step 6: Read *

* = operator.

Stack is empty → push it.

Stack: *

Output: AB+

Step 7: Read C

C = operand → directly to output.

Stack: *

Output: AB+C

Step 8: End of Expression

Pop everything left in stack.

Pop * → goes to output.

Stack: (empty)

Output: AB+C* 



Student Task: DRY RUN the following expression:

1. (A+B*C)+D

expected postfix: ABC*+D+

2. (A+B)*(C-D)/E

expected postfix: AB+CD-*E/







Infix → Prefix Conversion (Rules):
===================================


--Prefix conversion is similar but scans from right to left.

Rules:
------


1. Operands: Directly add to prefix expression.

2. Right Parenthesis ): Push onto stack.

3. Left Parenthesis (: Pop until ) is found.

4. Operators:

--While the stack is not empty and the operator on top has higher precedence, pop and add to prefix expression.

--Then push the current operator.

5. At the end: Pop all operators.



Example 1: A + B * C
--------------------


Step 1: Operand C → Prefix: C

Step 2: Operator * → Stack: *

Step 3: Operand B → Prefix: B C

Step 4: Operator + → Lower precedence than * → Pop * → Prefix: * B C, push +

Step 5: Operand A → Prefix: A * B C

End: Pop stack (+) → + A * B C


Result Prefix: + A * B C




Example 2: (A + B) * C
-----------------------

Step 1: Operand C → Prefix: C

Step 2: Operator * → Stack: *

Step 3: ) → push → Stack: * )

Step 4: Operand B → Prefix: B C

Step 5: Operator + → push → Stack: * ) +

Step 6: Operand A → Prefix: A B C

Step 7: ( → Pop until ) → Prefix: + A B C

End: Pop * → * + A B C

Result Prefix: * + A B C



Code:
-----

--Trick: Instead of writing a completely new algorithm, we can use this smart approach:

1. Reverse the infix string.

2. Replace ( with ) and vice versa.

3. Convert using infixToPostfix.

4. Reverse the result → that’s the Prefix!

Example: (A + B) * C


step1: reverse the expression: C * ) B + A (

step2: Replace ( with ) and vice versa: C * ( B + A )

step3: converting infix to postfix: C B A + *

step4: reversing the result: * + A B C






Example:
--------

#include <iostream>
#include <stack>
#include <algorithm> // for reverse
#include <cctype>
using namespace std;

int precedence(char op) {
    if (op == '^') return 3;
    if (op == '*' || op == '/' || op == '%') return 2;
    if (op == '+' || op == '-') return 1;
    return -1;
}

string infixToPostfix(string exp) {
    stack<char> st;
    string result = "";

    for (char ch : exp) {
        if (isalnum(ch)) {
            result += ch;
        }
        else if (ch == '(') {
            st.push(ch);
        }
        else if (ch == ')') {
            while (!st.empty() && st.top() != '(') {
                result += st.top();
                st.pop();
            }
            if (!st.empty()) 
		st.pop();
        }
        else {
            while (!st.empty() && precedence(st.top()) >= precedence(ch)) {
                result += st.top();
                st.pop();
            }
            st.push(ch);
        }
    }
    while (!st.empty()) {
        result += st.top();
        st.pop();
    }
    return result;
}

string infixToPrefix(string exp) {
    // Step 1: Reverse the string
    reverse(exp.begin(), exp.end());

    // Step 2: Swap ( and )
    for (char &ch : exp) {
        if (ch == '(') 
		ch = ')';
        else if (ch == ')') 
		ch = '(';
    }

    // Step 3: Convert to Postfix
    string postfix = infixToPostfix(exp);

    // Step 4: Reverse Postfix to get Prefix
    reverse(postfix.begin(), postfix.end());

    return postfix;
}

int main() {
    string exp = "(A+B)*C";
    cout << "Infix Expression: " << exp << endl;
    cout << "Prefix Expression: " << infixToPrefix(exp) << endl;
    return 0;
}




Bug in above Postfix and prefix code:
======================================


Issue with ^ Operator:

example: in postfix code: 

for the expression: A^B^C

the output should be: ABC^^

because: ^ exponent operator associtivity is right-associative.

But in our code, we are treating all operators as left-associative because of this line:

while (!st.empty() && precedence(st.top()) >= precedence(ch)) {
    result += st.top();
    st.pop();
}


--For ^, this will wrongly pop earlier instead of allowing right-to-left evaluation.


Fixing: Handle Associativity:
----------------------------

Here We need to check associativity.

1. Left-associative operators → pop if precedence(top) >= precedence(current)

2. Right-associative operators (like ^) → pop if precedence(top) > precedence(current)



final code:
-------------

#include <iostream>
#include <stack>
#include <cctype>  // for isalnum
using namespace std;

// Function to return precedence of operators
int precedence(char op) {
    if (op == '^') return 3;
    if (op == '*' || op == '/' || op == '%') return 2;
    if (op == '+' || op == '-') return 1;
    
    // for any other charecter except: above operators
    return -1;
}


// Function to check if operator is right-associative
bool isRightAssociative(char op) {
    return op == '^';
}


// Function to convert Infix to Postfix
string infixToPostfix(string exp) {
    stack<char> st;
    string result = "";

    for (char ch : exp) {
        // 1. If operand, add to result
        if (isalnum(ch)) {
            result += ch;
        }
        // 2. If '(', push to stack
        else if (ch == '(') {
            st.push(ch);
        }
        // 3. If ')', pop until '('
        else if (ch == ')') {
            while (!st.empty() && st.top() != '(') {
                result += st.top();
                st.pop();
            }
            if (!st.empty()) 
		        st.pop(); // pop '('
        }
        // 4. If operator
        else { // operator
            while (!st.empty() && 
                   ((isRightAssociative(ch) && precedence(st.top()) > precedence(ch)) ||
                   (!isRightAssociative(ch) && precedence(st.top()) >= precedence(ch)))) {
                result += st.top();
                st.pop();
            }
            st.push(ch);
        }

    }

    // Pop remaining operators
    while (!st.empty()) {
        result += st.top();
        st.pop();
    }

    return result;
}

int main() {
    string exp = "A^(B^C)";
    cout << "Infix Expression: " << exp << endl;
    cout << "Postfix Expression: " << infixToPostfix(exp) << endl;
    
    return 0;
}








Student task: fix the prefix conversion also.



Evaluating the PostFix expression:
==================================


--Postfix notations are also called as Reverse Polish Notation (RPN)

--Opertor comes after operands.

Example:

Infix: (2+3)*5

Postfix: 23+5*

After evaluating the result is: 25



Postfix Evaluation Algorithm:
----------------------------

1. Create an empty stack.

2. Traverse the expression from left to right

--If the symbol is an operand(number) : push into the stack

--If the symbol is an operator (+,-,/,^,%): 

---pop the top two operands from the stack.
---Apply operator
---push the result back into the stack.


3. After processing the expression, the top of the stack will contains the result.



Code: Single digit version:
--------------------------


#include <iostream>
#include <stack>
#include <cctype>
#include <cmath>

using namespace std;

int applyOp(int a, int b, char op) {
    switch(op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b; // assume b ≠ 0
        case '%': return a % b;
        case '^': return pow(a, b);
    }
    return 0;
}

int evaluatePostfix(string exp) {
    stack<int> st;

    for (char ch : exp) {
        if (isdigit(ch)) {
            st.push(ch - '0'); // convert char to int
        }
        else {
            int val2 = st.top(); st.pop();
            int val1 = st.top(); st.pop();
            int result = applyOp(val1, val2, ch);
            st.push(result);
        }
    }
    return st.top();
}

int main() {
    string exp = "23+5*";  // equivalent to (2+3)*5
    cout << "Postfix Expression: " << exp << endl;
    cout << "Evaluated Value: " << evaluatePostfix(exp) << endl;
    return 0;
}





Evaluating the Prefix expression:
==================================

--The prefix expression is also called as Polish Notation.

--Here Operator comes before the operands

Example: 

Infix: (2+3)*5
Prefix: *+235


Prefix Evaluation Algorithm:
----------------------------

--Trick: Process expression right → left (reverse direction).



Code: Single digit version:
---------------------------


#include <iostream>
#include <stack>
#include <cctype>
#include <cmath>

using namespace std;

int applyOp(int a, int b, char op) {
    switch(op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        case '%': return a % b;
        case '^': return pow(a, b);
    }
    return 0;
}

int evaluatePrefix(string exp) {
    stack<int> st;

    for (int i = exp.size() - 1; i >= 0; i--) {
        char ch = exp[i];
        if (isdigit(ch)) {
            st.push(ch - '0');
        }
        else {
            int val1 = st.top(); st.pop();
            int val2 = st.top(); st.pop();
            int result = applyOp(val1, val2, ch);
            st.push(result);
        }
    }
    return st.top();
}

int main() {
    string exp = "*+235";  // equivalent to (2+3)*5
    cout << "Prefix Expression: " << exp << endl;
    cout << "Evaluated Value: " << evaluatePrefix(exp) << endl;
    return 0;
}





Note: The above version of the code for Postfix and Prefix will work only with the Single digit numbers (0-9).

--They cannot evaluate "10 20 + 30 *" directly;



Generalized Version (Multi-digit Numbers with Tokens): RPN calculator
===================================================

Instead of reading character by character, we read tokens (strings) such as "10", "20", "+".


Postfix Evaluation (with tokens)
------------------------------

#include <iostream>
#include <stack>
#include <vector>
#include <cmath>
using namespace std;

int applyOp(int a, int b, string op) {
    if (op == "+") return a + b;
    if (op == "-") return a - b;
    if (op == "*") return a * b;
    if (op == "/") return a / b;
    if (op == "%") return a % b;
    if (op == "^") return pow(a, b);
    return 0;
}

int evaluatePostfix(vector<string> tokens) {
    stack<int> st;

    for (string token : tokens) {
        if (token == "+" || token == "-" || token == "*" || token == "/" || token == "%" || token == "^") {
            int val2 = st.top(); st.pop();
            int val1 = st.top(); st.pop();
            st.push(applyOp(val1, val2, token));
        }
        else {
            st.push(stoi(token)); // convert string → int
        }
    }
    return st.top();
}

int main() {
    vector<string> exp = {"10", "20", "+", "30", "*"};  // (10+20)*30
    cout << "Result: " << evaluatePostfix(exp) << endl;
    return 0;
}


Prefix Evaluation (with tokens):
-------------------------------

#include <iostream>
#include <stack>
#include <vector>
#include <cmath>
using namespace std;

int applyOp(int a, int b, string op) {
    if (op == "+") return a + b;
    if (op == "-") return a - b;
    if (op == "*") return a * b;
    if (op == "/") return a / b;
    if (op == "%") return a % b;
    if (op == "^") return pow(a, b);
    return 0;
}

int evaluatePrefix(vector<string> tokens) {
    stack<int> st;
    for (int i = tokens.size() - 1; i >= 0; i--) {
        string token = tokens[i];
        if (token == "+" || token == "-" || token == "*" || token == "/" || token == "%" || token == "^") {
            int val1 = st.top(); st.pop();
            int val2 = st.top(); st.pop();
            st.push(applyOp(val1, val2, token));
        }
        else {
            st.push(stoi(token));
        }
    }
    return st.top();
}

int main() {
    vector<string> exp = {"*", "+", "10", "20", "30"};  // (10+20)*30
    cout << "Result: " << evaluatePrefix(exp) << endl;
    return 0;
}




Next Greater Element (NGE):
===========================

Problem Statement:
------------------

--You are given an array of numbers, e.g., arr = [4, 5, 2, 25].

--For each element in the array, you need to find the first greater element to its right.

--If there is no greater element to the right, return -1 for that element.

Example:
--------

Input: arr = [4, 5, 2, 25]
Output: [5, 25, 25, -1]


Explanation:

4 → next greater is 5

5 → next greater is 25

2 → next greater is 25

25 → no greater element → -1



Solution Approach1 using Stack:
------------------------------

--We can also solve this efficiently using a stack by traversing from right to left:

1. Initialize an empty stack.

2. Traverse the array from right to left.

3. For each element current:

--While the stack is not empty and stack.top() <= current → pop from the stack.

--If the stack is empty → no greater element exists → result[i] = -1.

--Else → stack.top() is the Next Greater Element → result[i] = stack.top().

--Push current onto the stack.

4. After traversal, the result array contains all NGEs.


In summery:
----------

--The stack always keeps the “potential greater elements” from the right side.

--If the stack’s top element is smaller than the current element, then it can never be the Next Greater Element (NGE) → so we remove (pop) it.

--If a bigger element remains on the stack → that is the NGE for the current element.

--If nothing is left in the stack → it means there is no greater element → put -1.


Time Complexity: O(n)
Space Complexity: O(n)


Step-by-Step Example:
--------------------

Array: [4, 5, 2, 25]

Stack: [] (stores actual values)
Result: [?, ?, ?, ?]


Step 1: i = 3, Current = 25

--Stack empty → result[3] = -1

--Push 25 → stack = [25]

Result = [?, ?, ?, -1]


Step 2: i = 2, Current = 2

--Stack.top() = 25, 25 <=  2  → stop

--Stack not empty → result[2] = 25

--Push 2 → stack = [25, 2]

Result = [?, ?, 25, -1]


Step 3: i = 1, Current = 5

--Stack.top() = 2, 2 <= 5  → pop 2 → stack = [25]

--Stack.top() = 25, 25 <= 5  → stop

--Stack not empty → result[1] = 25

--Push 5 → stack = [25, 5]

Result = [?, 25, 25, -1]


Step 4: i = 0, Current = 4

--Stack.top() = 5, 5 <= 4  → stop

--Stack not empty → result[0] = 5

--Push 4 → stack = [25, 5, 4]

Result = [5, 25, 25, -1]


Final Result: [5, 25, 25, -1]



Note: A stack that always maintains its elements in either increasing order or decreasing order is called a "monotonic stack". 
When a new element comes, we pop from the stack until the order (increasing or decreasing) is preserved.

--This helps us solve problems like Next Greater Element, Next Smaller Element.


Code:
------
#include <iostream>
#include <stack>
#include <vector>
using namespace std;

vector<int> nextGreaterElement(vector<int>& arr) {

    int n = arr.size();
    vector<int> result(n);
    stack<int> st; // stack stores potential NGEs

// Traverse from right to left
    for (int i = n-1; i >= 0; i--) {
        int current = arr[i];

 // Pop all smaller or equal elements
        while (!st.empty() && st.top() <= current) {
            st.pop();
        }

// If stack empty → no greater element
        if (st.empty()) {
            result[i] = -1;
        } else {
            result[i] = st.top();
        }

 // Push current element
        st.push(current);
    }

    return result;
}

int main() {
    vector<int> arr = {4, 5, 2, 25};
    vector<int> res = nextGreaterElement(arr);

    cout << "Next Greater Elements: ";
    for (int x : res)
        cout << x << " ";
    cout << endl;
    return 0;
}




Time complexity:

--Outer loop runs n times.

--Inner while loop: Each element is pushed once and popped once from the stack → O(n) overall.

So total = O(n) + O(n) = O(n)

Space Complexity: O(n)














Approach2: Left-to-Right Traversal (Using Stack of Indices)
-------------------------------------------------------

--This approach is also very popular because it directly finds the NGE while scanning left to right.

Idea:
-----

1. Traverse the array from left to right.

2. Use a stack to store indices of elements for which the NGE hasn’t been found yet.

3. For each new element: 

--check if it’s greater than the element at the index on top of the stack.

--If yes → this new element is the NGE for that index stored inside the top of the stack → update result and pop the stack.

--Repeat until stack is empty or top element is greater than or equal to the current element.

4. push the current element index onto the stack.


--At the end, indices left in stack have no greater element → assign -1.



Step-by-Step Dry Run:

Array = [4, 5, 2, 25]
Result = [-1, -1, -1, -1] (initialized with -1)
Stack = [] (stores indices)


Step 1: i = 0, Current = 4

Stack empty → no pop.

Push index 0.

Stack = [0] → (represents arr[0] = 4)
Result = [-1, -1, -1, -1]

Step 2: i = 1, Current = 5

Compare arr[1] = 5 with arr[st.top()] = arr[0] = 4
→ 5 > 4 → result[0] = 5 → pop 0.

Stack empty now.

Push index 1.

Stack = [1] → (represents arr[1] = 5)
Result = [5, -1, -1, -1]



Step 3: i = 2, Current = 2

Compare arr[2] = 2 with arr[st.top()] = arr[1] = 5
→ 2 ≤ 5 → stop.

Push index 2.

Stack = [1, 2] → (represents arr[1] = 5, arr[2] = 2)
Result = [5, -1, -1, -1]


Step 4: i = 3, Current = 25

Compare arr[3] = 25 with arr[st.top()] = arr[2] = 2
→ 25 > 2 → result[2] = 25 → pop 2.

Compare arr[3] = 25 with arr[st.top()] = arr[1] = 5
→ 25 > 5 → result[1] = 25 → pop 1.

Stack empty now.

Push index 3.

Stack = [3] → (represents arr[3] = 25)
Result = [5, 25, 25, -1]


End of Array

Remaining index = 3 → already has -1 (default).

Stack = []
Result = [5, 25, 25, -1]


#include <iostream>
#include <stack>
#include <vector>
using namespace std;

vector<int> nextGreaterElementIndices(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, -1); // Initialize result with -1
    stack<int> st;             // Stack stores indices

    for (int i = 0; i < n; i++) {
      
    // While the stack is not empty and the current element is greater than the element at the stack's top index
        while (!st.empty() && arr[i] > arr[st.top()]) {
		int idx = st.top();
		st.pop();
            result[idx] = arr[i]; // arr[i] is the NGE for the element at index st.top()
        }
     
     st.push(i); // Push current index
    
  }
    // Any indices left in the stack have no greater element
   // Remaining indices in stack → NGE = -1 (already set)
    return result;
}







Problem:  Previous Smaller Element:
=================================

--For each element, find the first element to its left that is smaller than it.

Logic: Mirror of NGE. Iterate from left to right and maintain a monotonic stack of increasing elements.


code:
-----

#include <vector>
#include <stack>
using namespace std;



vector<int> prevSmaller(vector<int> & arr) {
    int n = arr.size();
    vector<int> result(n);
    stack<int> st;

    for (int i = 0; i < n; ++i) {
        // Pop elements from the stack that are greater than or equal to the current
        while (!st.empty() && st.top() >= arr[i]) {
            st.pop();
        }

        if (st.empty()) {
            result[i] = -1; // No smaller element to the left
        } else {
            result[i] = st.top();
        }
        st.push(arr[i]);
    }
    return result;
}







Circular Array:
================

--A circular array is an array where the end of the array "wraps around" to connect back to the beginning. (After the last index, we can continue from index 0.)

--It is used to efficiently utilize memory in fixed-size data structures like circular queues.

--In a normal array (linear), once we reach the end, we cannot insert more elements.

--But in a circular array, after reaching the last index, we can wrap around and start from index 0 (if space is available).


--To achieve this wrapping, we use the modulus operator (%).


formular for circular indexing:
-----------------------------

Example:

--Suppose we have an array of size 5:

Index:  0   1   2   3   4

If we insert sequentially:

arr[0] = 10
arr[1] = 20
arr[2] = 30
arr[3] = 40
arr[4] = 50


--Now in a normal array, we cannot insert more values.

--But in a circular array, if some space is freed at the front (e.g., we remove elements from start, here slots are available), then we can reuse that space by wrapping around it.

formula is: index = i % size;

--if we are starting with any value then: 

index = (start + i) % SIZE;   //i start with 0

--If index reaches the end, then next index will become 0.


Example: SIZE = 5

(0+0) % 5 = 0

(0+1) % 5 = 1

(0+2) % 5 = 2

(0+3) % 5 = 3

(0+4) % 5 = 4

(0+ 5) % 5= 0 ( wrap around)



lets take :

Index:   0   1   2   3   4
Array: [10, 20, 30, 40, 50]


Linear way: after 50 nothing is there 
Circular way: after 50 we reach to the the 10


Example: 


int arr[5] = {10,20,30,40,50};

int size= sizeof(arr)/sizeof(arr[0]);

cout<<"Normal array printing \n";
for(int i=0;i<size;i++){

	cout<<arr[i] <<" "; 

}

cout<<endl;



cout<<"Circular array printing starting from index 2: \n";
int start = 2;

for(int i=0;i<size;i++){

	int ci= (start+i) % size;
	cout<<arr[ci] <<" ";
}

cout<<endl;



Problem 3 : Next Greater Element II (Circular Array)
===================================================


--Given a circular array, for each element, find the next greater element. If no such element exists, return -1.

--Same as NGE, but the input array is circular.

--Difference from normal NGE: After the last element, you can wrap around and continue checking from the beginning.


Example:

Input: arr = [1, 2, 1]
Output: [2, -1, 2]

Explanation:
1 → next greater is 2
2 → no greater → -1
1 → wrap around → next greater is 2


IDEA:
-----

1. Use the same logic as NGE first approach.
2. Since the array is circular, traverse the array twice (2 * n) to simulate the circular behaviour.(instead of traversing the array circularly for each element again to find the NGE, it will raise the TC to O(n^2), to get the result optamized way we can traverse the array 2 times).

example:

for the array: [4,5,2,15,14]


result: [5,15,15,-1,15]

for 4: traverse all the right side (5,2,15,14): left: no element
for 5: traverse all the right side (2,15,14): left: (4)
for 2: traverse all the right side (15,14): left: (4,5)
for 15: traverse all the right side (14): left: (4,5,2)
for 14: traverse all the right side: nothing : left: (4,5,2,15)

3. Use modulus % to wrap indices.

4. here inside the stack store the indexes instead of storing the value directly otherwise duplicate value may cause the problem.


Code:
------
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

// Function to find Next Greater Elements in a Circular Array
vector<int> nextGreaterElementCircular(vector<int>& arr) {

  int n= arr.size();

    vector<int> result(n);

    stack<int> st;

    for(int i=2*n-1; i>=0;i--){

	int idx= i % n;

        while(!st.empty() && arr[st.top()] <= arr[idx]){
            st.pop();
        }

        if(st.empty()){
            result[idx] = -1;
        }else{
            result[idx] = arr[st.top()];
        }

        st.push(idx);
    }




    return result;
}


int main() {
    vector<int> arr = {1, 2, 1};
    vector<int> res = nextGreaterElementCircular(arr);

    cout << "Next Greater Elements (Circular): ";
    for (int x : res) {
        cout << x << " ";
    }
    cout << endl;

    return 0;
}


Dry Run:
--------

Array: arr = [1, 2, 1]
Length: n = 3
Result: [?, ?, ?]
Stack: stores indices.

Step 1: 

i = 5 → idx = 5 % 3 = 2 → arr[2] = 1

Stack empty → no pop
Stack empty → result[2] = -1
Push 2 → stack = [2]
Result: [?, ?, -1]

Step 2: 

i = 4 → idx = 4 % 3 = 1 → arr[1] = 2

Compare arr[st.top()] = arr[2] = 1
1 <= 2 → pop 2 → stack = []
Stack empty → result[1] = -1
Push 1 → stack = [1]
Result: [?, -1, -1]


Step 3: 

i = 3 → idx = 3 % 3 = 0 → arr[0] = 1

Compare arr[st.top()] = arr[1] = 2
2 > 1 → stop
Stack not empty → result[0] = arr[1] = 2
Push 0 → stack = [1, 0]
Result: [2, -1, -1]


Step 4: 

i = 2 → idx = 2 % 3 = 2 → arr[2] = 1
Compare arr[st.top()] = arr[0] = 1
1 <= 1 → pop 0 → stack = [1]
Compare arr[st.top()] = arr[1] = 2
2 > 1 → stop
Stack not empty → result[2] = arr[1] = 2
Push 2 → stack = [1, 2]
Result: [2, -1, 2]


Step 5: 

i = 1 → idx = 1 % 3 = 1 → arr[1] = 2
Compare arr[st.top()] = arr[2] = 1
1 <= 2 → pop 2 → stack = [1]
Compare arr[st.top()] = arr[1] = 2
2 <= 2 → pop 1 → stack = []
Stack empty → result[1] = -1
Push 1 → stack = [1]
Result: [2, -1, 2]


Step 6: 

i = 0 → idx = 0 % 3 = 0 → arr[0] = 1
Compare arr[st.top()] = arr[1] = 2
2 > 1 → stop
Stack not empty → result[0] = arr[1] = 2
Push 0 → stack = [1, 0]
Result: [2, -1, 2]

Final Output: [2, -1, 2]